- name: Initialize target repository with content
        if: inputs.operation == 'create-repo-full' && inputs.dry_run == false && (steps.check-target.outputs.repo_exists == 'false' || inputs.force_recreate == 'true')
        run: |
          set -e
          # Check if repo already has content
          if gh api repos/${{ steps.set-target.outputs.target_repo_full }}/contents/README.md >/dev/null 2>&1; then
            echo "Repository already has content, skipping initialization"
            exit 0
          fi
          echo "Initializing target repository with content..."
          # Create temporary directory for initialization
          mkdir -p temp_init
          cd temp_init
          # Initialize git repository
          git init
          git config user.name "${{ github.triggering_actor }}"
          git config user.email "${{ github.triggering_actor }}@users.noreply.github.com"
          # Create initial README
          printf '%s\n' \
            "# ${{ inputs.target_repo }}" \
            "" \
            "Repository created and configured via GitHub Enterprise Actions workflow" \
            "" \
            "## Source Information" \
            "- **Source Repository**: ${{ inputs.template_repo }}" \
            "- **Created**: $(date)" \
            "- **Workflow**: GitHub Enterprise Repository Management" \
            "- **GitHub Enterprise Host**: $GH_HOST" \
            "" \
            "## Configuration Status" \
            "- Collaborator permissions (in progress)" \
            "- Branch protection rules (in progress)" \
            "- Content synchronization (in progress)" \
            > README.md
          git add README.md
          git commit -m "Initial commit with repository setup"
          # Setup remote and push with retry logic
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Initial push attempt $attempt/$max_attempts"
            # Use token-based authentication for push
            if git remote add origin "https://$GH_TOKEN@$GH_HOST/${{ steps.set-target.outputs.target_repo_full }}.git" && \
               git branch -M master && \
               git push -u origin master; then
              echo "Initial content pushed successfully"
              break
            else
              echo "ERROR: Initial push failed (attempt $attempt/$max_attempts)"
              git remote remove origin 2>/dev/null || true
              if [ $attempt -eq $max_attempts ]; then
                echo "Initial push failed after $max_attempts attempts, continuing anyway"
              else
                sleep 5
              fi
            fi
          done
          cd ..
          rm -rf temp_init



- name: Copy repository content and settings
        if: inputs.operation == 'create-repo-full' && inputs.dry_run == false && inputs.template_repo != ''
        run: |
          set -e
          echo "Syncing repository content from source to target..."
          
          if [ ! -d "source-repo" ]; then
            echo "Source repository not available, skipping content copy"
            exit 0
          fi
          
          echo "Cloning target repository: ${{ steps.set-target.outputs.target_repo_full }}"
          
          set +e
          gh repo clone "${{ steps.set-target.outputs.target_repo_full }}" target-repo
          clone_result=$?
          set -e
          
          if [ $clone_result -ne 0 ]; then
            echo "Failed to clone target repository, skipping content sync"
            exit 0
          fi
          
          cd target-repo
          
          # Check which branch exists (master or main)
          current_branch=$(git branch --show-current)
          echo "Current branch in target repo: $current_branch"
          
          # If current branch is not master, create and switch to master
          if [ "$current_branch" != "master" ]; then
            echo "Switching to master branch..."
            set +e
            git checkout master 2>/dev/null
            checkout_result=$?
            set -e
            
            if [ $checkout_result -ne 0 ]; then
              # Master doesn't exist, create it from current branch
              echo "Creating master branch from $current_branch..."
              git checkout -b master
            fi
          fi
          
          # Copy all files from source (excluding .git)
          rsync -av --exclude='.git' ../source-repo/ ./
          
          git config user.name "${{ github.triggering_actor }}"
          git config user.email "${{ github.triggering_actor }}@users.noreply.github.com"
          
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Copy content from source repository ${{ inputs.template_repo }}"
            
            max_attempts=3
            for attempt in $(seq 1 $max_attempts); do
              echo "Content push to master branch attempt $attempt/$max_attempts"
              
              set +e
              git push origin master
              push_result=$?
              set -e
              
              if [ $push_result -eq 0 ]; then
                echo "Content pushed to master branch successfully"
                break
              else
                echo "Push failed, checking if we need to set upstream..."
                set +e
                git push --set-upstream origin master
                push_upstream_result=$?
                set -e
                
                if [ $push_upstream_result -eq 0 ]; then
                  echo "Content pushed to master branch with upstream set"
                  break
                elif [ $attempt -eq $max_attempts ]; then
                  echo "Content push failed after $max_attempts attempts"
                  echo "Trying to push current branch as fallback..."
                  git push origin HEAD:master || {
                    echo "All push attempts failed, but continuing workflow"
                    exit 0
                  }
                  break
                else
                  sleep 5
                fi
              fi
            done
          fi
          cd ..






name: GitHub Enterprise Repository Management
on:
  workflow_dispatch:
    inputs:
      operation:
        description: 'Select operation: create-repo-full (creates new repo OR updates existing - idempotent/rerunnable), copy-collaborators-only, copy-protection-only, or sync-all-settings (update settings only)'
        required: true
        type: choice
        options:
          - 'create-repo-full'
          - 'copy-collaborators-only'
          - 'copy-protection-only'
          - 'sync-all-settings'
        default: 'create-repo-full'
      template_repo:
        description: 'Source template repository in format: XXX/template-repo-name (leave empty for basic repo setup without copying)'
        required: false
        type: string
        default: ''
      target_repo:
        description: 'Target repository in format: XXX/new-repo-name (preferred) OR just the repo name if using target_org below'
        required: true
        type: string
        default: 'XXX/'
      target_org:
        description: 'Organization name (only needed if target_repo is just a name like "Misc" without org prefix. Leave blank if target_repo is XXX/Misc format)'
        required: false
        type: string
        default: ''
      repo_description:
        description: 'Short description for the new repository (shown on GitHub)'
        required: false
        type: string
        default: 'Repository created via GitHub Actions'
      private_repo:
        description: 'Repository visibility: true = Private (restricted access), false = Public (everyone can see)'
        required: false
        type: boolean
        default: false
      collaborators:
        description: 'Add collaborators (JSON): [{"username":"user1","permission":"admin"},{"username":"user2","permission":"write"}] - permissions: admin, write, read'
        required: false
        type: string
        default: '[]'
      teams:
        description: 'Add teams (JSON): [{"team":"team-name","permission":"admin"},{"team":"team2","permission":"write"}] - permissions: admin, write, read'
        required: false
        type: string
        default: '[]'
      dry_run:
        description: 'Dry run mode: true = Preview actions without making changes, false = Execute all changes'
        required: false
        type: boolean
        default: false
      force_recreate:
        description: 'Attempt to delete and recreate if repo exists (Note: May be blocked by GitHub Enterprise policy - will update instead if deletion fails)'
        required: false
        type: boolean
        default: false
      github_hostname:
        description: 'GitHub Enterprise hostname (e.g., github.company.com) - change only if not using default enterprise instance'
        required: false
        type: string
        default: 'github.com'
      target_branches:
        description: 'Target branches to protect (comma-separated, leave empty to use all protected branches from source)'
        required: false
        type: string
        default: ''

env:
  GH_HOST: ${{ inputs.github_hostname }}
  GH_TOKEN: ${{ secrets.GH_FUNC_TOKEN }}
  GITHUB_TOKEN: ${{ secrets.GH_FUNC_TOKEN }}

jobs:
  github-enterprise-repo-management:
    runs-on: ['self-hosted', 'enterprise']
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Install GitHub CLI (Enterprise Compatible)
        run: |
          set -e
          echo "Installing GitHub CLI for enterprise environment..."
          
          if command -v apt-get >/dev/null 2>&1; then
            echo "Detected Debian/Ubuntu system"
            sudo mkdir -p /usr/share/keyrings
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y gh
          elif command -v yum >/dev/null 2>&1 || command -v dnf >/dev/null 2>&1; then
            echo "Detected RHEL/CentOS system"
            sudo dnf config-manager --add-repo https://cli.github.com/packages/rpm/gh-cli.repo
            sudo dnf install -y gh
          elif command -v apk >/dev/null 2>&1; then
            echo "Detected Alpine Linux"
            apk add --no-cache github-cli
          else
            echo "Using binary installation fallback"
            ARCH=$(uname -m)
            case $ARCH in
              x86_64) ARCH="amd64" ;;
              aarch64) ARCH="arm64" ;;
              armv7l) ARCH="armv6" ;;
            esac
            
            cd /tmp
            wget -q https://github.com/cli/cli/releases/latest/download/gh_*_linux_${ARCH}.tar.gz
            tar -xzf gh_*_linux_${ARCH}.tar.gz
            sudo mv gh_*/bin/gh /usr/local/bin/
            sudo chmod +x /usr/local/bin/gh
            rm -rf gh_*
            export PATH="/usr/local/bin:$PATH"
            echo "/usr/local/bin" >> $GITHUB_PATH
            
            if ! command -v gh >/dev/null 2>&1; then
              echo "ERROR: GitHub CLI installation failed"
              exit 1
            fi
          fi
          
          gh --version
          echo "GitHub CLI installed successfully"
          
      - name: Setup GitHub Enterprise Authentication
        run: |
          set -e
          echo "Setting up GitHub Enterprise authentication..."
          echo "GitHub Enterprise Host: $GH_HOST"
          
          echo "Testing connectivity to $GH_HOST..."
          if ! curl -I "https://$GH_HOST" >/dev/null 2>&1; then
            echo "ERROR: Cannot reach $GH_HOST"
            echo "Please check network connectivity and DNS resolution"
            exit 1
          fi
          echo "Connectivity to $GH_HOST confirmed"
          
          echo "Authenticating with GitHub Enterprise..."
          if [ "$GH_HOST" = "github.com" ]; then
            echo "$GH_TOKEN" | gh auth login --with-token
            gh auth status
            gh auth setup-git
          else
            echo "$GH_TOKEN" | gh auth login --hostname "$GH_HOST" --with-token
            gh auth status --hostname "$GH_HOST"
            gh auth setup-git --hostname "$GH_HOST"
          fi
          
          echo "GitHub Enterprise authentication completed"
          
      - name: Validate inputs and set target repository
        id: set-target
        run: |
          set -e
          echo "Validating inputs..."
          
          if [ -n "${{ inputs.template_repo }}" ]; then
            if [[ ! "${{ inputs.template_repo }}" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
              echo "ERROR: Template repository must be in format 'org/repo-name'"
              echo "Provided: '${{ inputs.template_repo }}'"
              exit 1
            fi
          fi
          
          if [ "${{ inputs.operation }}" = "create-repo-full" ]; then
            if [[ "${{ inputs.target_repo }}" =~ ^[^/]+/[^/]+$ ]]; then
              target_org=$(echo "${{ inputs.target_repo }}" | cut -d'/' -f1)
              target_repo_name=$(echo "${{ inputs.target_repo }}" | cut -d'/' -f2)
              echo "target_org=$target_org" >> $GITHUB_OUTPUT
              echo "target_repo_full=$target_org/$target_repo_name" >> $GITHUB_OUTPUT
              echo "Parsed target_repo as org='$target_org', repo='$target_repo_name'"
            elif [ -n "${{ inputs.target_org }}" ]; then
              echo "target_org=${{ inputs.target_org }}" >> $GITHUB_OUTPUT
              echo "target_repo_full=${{ inputs.target_org }}/${{ inputs.target_repo }}" >> $GITHUB_OUTPUT
              echo "Using target_org='${{ inputs.target_org }}' with target_repo='${{ inputs.target_repo }}'"
            else
              echo "ERROR: Must provide either target_repo in 'org/repo' format or target_org parameter"
              exit 1
            fi
          else
            target_input="${{ inputs.target_repo }}"
            if [[ "$target_input" =~ ^https?://[^/]+/([^/]+)/([^/]+)(\.git)?/?$ ]]; then
              target_org="${BASH_REMATCH[1]}"
              target_repo_name="${BASH_REMATCH[2]}"
              target_repo_name="${target_repo_name%.git}"
              target_repo_full="$target_org/$target_repo_name"
              echo "Extracted from URL: $target_repo_full"
            elif [[ "$target_input" =~ ^[^/]+/[^/]+$ ]]; then
              target_repo_full="$target_input"
              target_org=$(echo "$target_input" | cut -d'/' -f1)
            else
              echo "ERROR: Target repository must be in format 'org/repo-name' or valid GitHub URL"
              exit 1
            fi
            echo "target_repo_full=$target_repo_full" >> $GITHUB_OUTPUT
            echo "target_org=$target_org" >> $GITHUB_OUTPUT
          fi
          
          echo "Input validation completed"
          echo "Target: $(cat $GITHUB_OUTPUT | grep target_repo_full | cut -d'=' -f2)"
          
      - name: Validate template repository access
        if: inputs.template_repo != ''
        run: |
          set -e
          echo "Validating template repository: ${{ inputs.template_repo }}"
          
          if [ "$GH_HOST" = "github.com" ]; then
            gh auth status || {
              echo "Re-authenticating..."
              echo "$GH_TOKEN" | gh auth login --with-token
            }
          else
            gh auth status --hostname "$GH_HOST" || {
              echo "Re-authenticating..."
              echo "$GH_TOKEN" | gh auth login --hostname "$GH_HOST" --with-token
            }
          fi
          
          if ! gh repo view "${{ inputs.template_repo }}" --json name,owner,description >/dev/null 2>&1; then
            echo "ERROR: Template repository ${{ inputs.template_repo }} not accessible"
            echo "Please check repository exists and token has access"
            exit 1
          fi
          echo "Template repository validated and accessible"
          
      - name: Check target repository existence and handle conflicts
        id: check-target
        run: |
          set -e
          target_repo="${{ steps.set-target.outputs.target_repo_full }}"
          echo "Checking target repository: $target_repo"
          
          set +e
          gh repo view "$target_repo" --json name,owner,createdAt,pushedAt 2>/dev/null > repo_info.json
          repo_check=$?
          set -e
          
          if [ $repo_check -eq 0 ]; then
            echo "repo_exists=true" >> $GITHUB_OUTPUT
            created_at=$(jq -r '.createdAt' repo_info.json)
            
            if command -v date >/dev/null 2>&1; then
              if date --version 2>/dev/null | grep -q GNU; then
                created_timestamp=$(date -d "$created_at" +%s)
              else
                created_timestamp=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$created_at" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S" "${created_at%Z}" +%s)
              fi
              current_timestamp=$(date +%s)
              age_minutes=$(( (current_timestamp - created_timestamp) / 60 ))
            else
              age_minutes=999
            fi
            
            echo "repo_age_minutes=$age_minutes" >> $GITHUB_OUTPUT
            echo "Repository exists, created $age_minutes minutes ago"
            
            if [ $age_minutes -lt 5 ]; then
              echo "repo_is_fresh=true" >> $GITHUB_OUTPUT
              echo "WARNING: Repository is very new (< 5 minutes old)"
            else
              echo "repo_is_fresh=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "repo_exists=false" >> $GITHUB_OUTPUT
            echo "repo_is_fresh=false" >> $GITHUB_OUTPUT
            echo "Repository does not exist"
          fi
          
      - name: Handle existing repository for create operation
        if: inputs.operation == 'create-repo-full' && steps.check-target.outputs.repo_exists == 'true'
        run: |
          set -e
          if [ "${{ inputs.force_recreate }}" = "true" ]; then
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "## DRY RUN - Repository Handling" >> $GITHUB_STEP_SUMMARY
              echo "Would attempt to delete and recreate: ${{ steps.set-target.outputs.target_repo_full }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "WARNING: Attempting to force recreate repository"
              
              set +e
              gh repo delete "${{ steps.set-target.outputs.target_repo_full }}" --yes 2>&1
              delete_result=$?
              set -e
              
              if [ $delete_result -eq 0 ]; then
                echo "Repository deleted successfully, will recreate"
                sleep 5
              else
                echo ""
                echo "=========================================="
                echo "WARNING: Repository Deletion Blocked"
                echo "=========================================="
                echo "Continuing with UPDATE mode instead..."
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "## Repository Update Mode" >> $GITHUB_STEP_SUMMARY
                echo "Repository deletion blocked - continuing with update mode" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          else
            echo "=========================================="
            echo "Repository Already Exists - Continuing with Update"
            echo "=========================================="
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Repository Update Mode" >> $GITHUB_STEP_SUMMARY
            echo "Repository exists - continuing with update mode" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Create target repository with enterprise support
        if: inputs.operation == 'create-repo-full' && (steps.check-target.outputs.repo_exists == 'false' || inputs.force_recreate == 'true')
        run: |
          set -e
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "## DRY RUN - Repository Creation" >> $GITHUB_STEP_SUMMARY
            echo "Would create repository: ${{ steps.set-target.outputs.target_repo_full }}" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          VISIBILITY_FLAG=""
          if [ "${{ inputs.private_repo }}" = "true" ]; then
            VISIBILITY_FLAG="--private"
          else
            VISIBILITY_FLAG="--public"
          fi
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Repository creation attempt $attempt/$max_attempts"
            
            set +e
            gh repo create "${{ steps.set-target.outputs.target_repo_full }}" \
              --description "${{ inputs.repo_description }}" \
              $VISIBILITY_FLAG \
              --clone=false
            create_result=$?
            set -e
            
            if [ $create_result -eq 0 ]; then
              echo "Repository created successfully"
              echo "## Repository Created" >> $GITHUB_STEP_SUMMARY
              echo "- **Repository**: ${{ steps.set-target.outputs.target_repo_full }}" >> $GITHUB_STEP_SUMMARY
              echo "- **URL**: https://$GH_HOST/${{ steps.set-target.outputs.target_repo_full }}" >> $GITHUB_STEP_SUMMARY
              break
            else
              if [ $attempt -eq $max_attempts ]; then
                echo "Repository creation failed"
                exit 1
              fi
              sleep 10
            fi
          done
          
      - name: Clone source repository with enterprise authentication
        if: (inputs.operation == 'create-repo-full' || inputs.operation == 'sync-all-settings') && inputs.template_repo != ''
        run: |
          set -e
          
          if ! command -v gh >/dev/null 2>&1; then
            export PATH="/usr/local/bin:/usr/bin:$PATH"
          fi
          
          echo "Cloning source repository: ${{ inputs.template_repo }}"
          
          if [ "$GH_HOST" = "github.com" ]; then
            gh auth status || {
              echo "Re-authenticating for clone operation..."
              echo "$GH_TOKEN" | gh auth login --with-token
              gh auth setup-git
            }
          else
            gh auth status --hostname "$GH_HOST" || {
              echo "Re-authenticating for clone operation..."
              echo "$GH_TOKEN" | gh auth login --hostname "$GH_HOST" --with-token
              gh auth setup-git --hostname "$GH_HOST"
            }
          fi
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Clone attempt $attempt/$max_attempts"
            
            set +e
            gh repo clone "${{ inputs.template_repo }}" source-repo
            clone_result=$?
            set -e
            
            if [ $clone_result -eq 0 ]; then
              echo "Source repository cloned successfully"
              break
            else
              if [ $attempt -eq $max_attempts ]; then
                echo "Clone failed"
                exit 1
              fi
              sleep 5
              rm -rf source-repo 2>/dev/null || true
            fi
          done
          
          if [ ! -d "source-repo" ]; then
            echo "ERROR: Source repository clone verification failed"
            exit 1
          fi
          
      - name: Initialize target repository with content and master branch
        if: inputs.operation == 'create-repo-full' && inputs.dry_run == false && (steps.check-target.outputs.repo_exists == 'false' || inputs.force_recreate == 'true')
        run: |
          set -e
          
          set +e
          gh api repos/${{ steps.set-target.outputs.target_repo_full }}/contents/README.md >/dev/null 2>&1
          has_content=$?
          set -e
          
          if [ $has_content -eq 0 ]; then
            echo "Repository already has content, skipping initialization"
            exit 0
          fi
          
          echo "Initializing target repository with master branch..."
          mkdir -p temp_init
          cd temp_init
          
          git init
          git config user.name "${{ github.triggering_actor }}"
          git config user.email "${{ github.triggering_actor }}@users.noreply.github.com"
          
          printf "# %s\n\n" "${{ inputs.target_repo }}" > README.md
          printf "Repository created and configured via GitHub Enterprise Actions workflow\n\n" >> README.md
          printf "## Source Information\n" >> README.md
          printf "- **Source Repository**: %s\n" "${{ inputs.template_repo }}" >> README.md
          printf "- **Created**: %s\n" "$(date)" >> README.md
          printf "- **Workflow**: GitHub Enterprise Repository Management\n" >> README.md
          printf "- **GitHub Enterprise Host**: %s\n" "$GH_HOST" >> README.md
          printf "\n## Configuration Status\n" >> README.md
          printf "- Collaborator permissions (in progress)\n" >> README.md
          printf "- Branch protection rules (in progress)\n" >> README.md
          printf "- Content synchronization (in progress)\n" >> README.md
          
          git add README.md
          git commit -m "Initial commit with repository setup"
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Initial push to master branch attempt $attempt/$max_attempts"
            
            set +e
            if git remote add origin "https://$GH_TOKEN@$GH_HOST/${{ steps.set-target.outputs.target_repo_full }}.git" && \
               git branch -M master && \
               git push -u origin master; then
              echo "Initial content pushed to master branch successfully"
              push_result=0
            else
              push_result=1
            fi
            set -e
            
            if [ $push_result -eq 0 ]; then
              break
            else
              git remote remove origin 2>/dev/null || true
              if [ $attempt -eq $max_attempts ]; then
                echo "Initial push failed, continuing anyway"
              else
                sleep 5
              fi
            fi
          done
          
          cd ..
          rm -rf temp_init
          
      - name: Wait for repository to be fully available
        if: inputs.operation == 'create-repo-full'
        run: |
          set -e
          target_repo="${{ steps.set-target.outputs.target_repo_full }}"
          echo "Waiting for repository to be ready..."
          
          max_wait=60
          interval=5
          elapsed=0
          
          while [ $elapsed -lt $max_wait ]; do
            set +e
            gh api repos/$target_repo >/dev/null 2>&1
            api_result=$?
            set -e
            
            if [ $api_result -eq 0 ]; then
              echo "Repository is now available"
              break
            else
              echo "Waiting... ($elapsed seconds elapsed)"
              sleep $interval
              elapsed=$((elapsed + interval))
            fi
          done
          
          if [ $elapsed -ge $max_wait ]; then
            echo "ERROR: Repository still not available"
            exit 1
          fi
          
      - name: Copy collaborators with enterprise authentication
        if: inputs.operation == 'create-repo-full' || inputs.operation == 'copy-collaborators-only' || inputs.operation == 'sync-all-settings'
        run: |
          set -e
          
          if ! command -v gh >/dev/null 2>&1; then
            export PATH="/usr/local/bin:/usr/bin:$PATH"
          fi
          
          if [ -z "${{ inputs.template_repo }}" ]; then
            echo "No template repository specified, skipping collaborator copy"
            exit 0
          fi
          
          echo "Copying collaborators from ${{ inputs.template_repo }} to ${{ steps.set-target.outputs.target_repo_full }}"
          
          if [ "$GH_HOST" = "github.com" ]; then
            gh auth status || {
              echo "Re-authenticating..."
              echo "$GH_TOKEN" | gh auth login --with-token
            }
          else
            gh auth status --hostname "$GH_HOST" || {
              echo "Re-authenticating..."
              echo "$GH_TOKEN" | gh auth login --hostname "$GH_HOST" --with-token
            }
          fi
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Fetching collaborators attempt $attempt/$max_attempts"
            
            set +e
            gh api repos/${{ inputs.template_repo }}/collaborators \
              --jq '.[] | {login: .login, permissions: .permissions, role_name: .role_name}' > collaborators.json
            fetch_result=$?
            set -e
            
            if [ $fetch_result -eq 0 ]; then
              echo "Collaborators fetched successfully"
              break
            else
              if [ $attempt -eq $max_attempts ]; then
                echo "Failed to fetch collaborators, skipping this step"
                exit 0
              fi
              sleep 5
            fi
          done
          
          if [ ! -s collaborators.json ]; then
            echo "No collaborators found in template repository"
            exit 0
          fi
          
          echo "## Collaborator Management" >> $GITHUB_STEP_SUMMARY
          echo "| User | Permission | Action | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------------|--------|--------|" >> $GITHUB_STEP_SUMMARY
          
          success_count=0
          error_count=0
          skip_count=0
          
          while IFS= read -r collaborator; do
            login=$(echo "$collaborator" | jq -r '.login')
            admin=$(echo "$collaborator" | jq -r '.permissions.admin')
            push=$(echo "$collaborator" | jq -r '.permissions.push')
            pull=$(echo "$collaborator" | jq -r '.permissions.pull')
            
            target_owner=$(echo "${{ steps.set-target.outputs.target_repo_full }}" | cut -d'/' -f1)
            if [ "$login" = "$target_owner" ]; then
              echo "| $login | owner | SKIP | Repository owner |" >> $GITHUB_STEP_SUMMARY
              skip_count=$((skip_count + 1))
              continue
            fi
            
            if [ "$admin" = "true" ]; then
              permission="admin"
            elif [ "$push" = "true" ]; then
              permission="push"
            else
              permission="pull"
            fi
            
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "| $login | $permission | DRY RUN | Would be added |" >> $GITHUB_STEP_SUMMARY
            else
              success=false
              for attempt in $(seq 1 3); do
                set +e
                gh api repos/${{ steps.set-target.outputs.target_repo_full }}/collaborators/$login \
                  -X PUT \
                  -f permission="$permission" 2>/dev/null
                add_result=$?
                set -e
                
                if [ $add_result -eq 0 ]; then
                  echo "| $login | $permission | ADD/UPDATE | SUCCESS |" >> $GITHUB_STEP_SUMMARY
                  success_count=$((success_count + 1))
                  success=true
                  break
                else
                  if [ $attempt -eq 3 ]; then
                    echo "| $login | $permission | ADD/UPDATE | FAILED |" >> $GITHUB_STEP_SUMMARY
                    error_count=$((error_count + 1))
                  else
                    sleep 2
                  fi
                fi
              done
            fi
          done < collaborators.json
          
          if [ "${{ inputs.dry_run }}" = "false" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Collaborator Summary**: $success_count successful, $error_count failed, $skip_count skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Copy branch protection rules with enterprise support
        if: inputs.operation == 'create-repo-full' || inputs.operation == 'copy-protection-only' || inputs.operation == 'sync-all-settings'
        run: |
          set -e
          
          if [ -z "${{ inputs.template_repo }}" ]; then
            echo "No template repository specified, skipping branch protection copy"
            exit 0
          fi
          
          export PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
          if command -v gh >/dev/null 2>&1; then
            GH_CMD="$(command -v gh)"
          elif [ -x "/usr/local/bin/gh" ]; then
            GH_CMD="/usr/local/bin/gh"
          elif [ -x "/usr/bin/gh" ]; then
            GH_CMD="/usr/bin/gh"
          else
            echo "ERROR: GitHub CLI not found"
            exit 1
          fi
          
          echo "Copying branch protection rules..."
          
          if [ "$GH_HOST" = "github.com" ]; then
            $GH_CMD auth status || {
              echo "$GH_TOKEN" | $GH_CMD auth login --with-token
            }
          else
            $GH_CMD auth status --hostname "$GH_HOST" || {
              echo "$GH_TOKEN" | $GH_CMD auth login --hostname "$GH_HOST" --with-token
            }
          fi
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Fetching source branches attempt $attempt/$max_attempts"
            
            set +e
            $GH_CMD api repos/${{ inputs.template_repo }}/branches --jq '.[].name' > source_branches.txt
            fetch_result=$?
            set -e
            
            if [ $fetch_result -eq 0 ]; then
              echo "Source branches fetched successfully"
              break
            else
              if [ $attempt -eq $max_attempts ]; then
                echo "Failed to fetch source branches, skipping protection copy"
                exit 0
              fi
              sleep 5
            fi
          done
          
          echo "Source branches: $(cat source_branches.txt | tr '\n' ' ')"
          
          for attempt in $(seq 1 $max_attempts); do
            echo "Fetching target branches attempt $attempt/$max_attempts"
            
            set +e
            output=$($GH_CMD api repos/${{ steps.set-target.outputs.target_repo_full }}/branches --jq '.[].name' 2>&1)
            fetch_result=$?
            set -e
            
            if [ $fetch_result -eq 0 ]; then
              echo "$output" > target_branches.txt
              echo "Target branches fetched successfully"
              break
            else
              if echo "$output" | grep -q "404\|Not Found\|empty repository"; then
                echo "Repository may be empty, creating empty file"
                touch target_branches.txt
                break
              fi
              
              if echo "$output" | grep -q "authentication\|401\|403"; then
                echo "Authentication issue, re-authenticating..."
                if [ "$GH_HOST" = "github.com" ]; then
                  echo "$GH_TOKEN" | $GH_CMD auth login --with-token
                else
                  echo "$GH_TOKEN" | $GH_CMD auth login --hostname "$GH_HOST" --with-token
                fi
              fi
              
              if [ $attempt -eq $max_attempts ]; then
                echo "Failed to fetch target branches, skipping protection copy"
                exit 0
              fi
              sleep 5
            fi
          done
          
          echo "Target branches: $(cat target_branches.txt | tr '\n' ' ')"
          
          > protected_branches.txt
          while IFS= read -r branch; do
            set +e
            $GH_CMD api repos/${{ inputs.template_repo }}/branches/$branch/protection > protection_${branch}.json 2>/dev/null
            prot_result=$?
            set -e
            
            if [ $prot_result -eq 0 ]; then
              echo "$branch" >> protected_branches.txt
            fi
          done < source_branches.txt
          
          > branches_to_protect.txt
          if [ -n "${{ inputs.target_branches }}" ]; then
            echo "${{ inputs.target_branches }}" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > branches_to_protect.txt
          else
            while IFS= read -r branch;
while IFS= read -r branch; do
              if grep -q "^$branch$" target_branches.txt; then
                echo "$branch" >> branches_to_protect.txt
              fi
            done < protected_branches.txt
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Branch Protection Management" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | Action | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|--------|" >> $GITHUB_STEP_SUMMARY
          
          protection_success=0
          protection_error=0
          
          if [ -s branches_to_protect.txt ]; then
            while IFS= read -r branch; do
              if [ -f "protection_${branch}.json" ]; then
                if [ "${{ inputs.dry_run }}" = "true" ]; then
                  echo "| $branch | DRY RUN | Would apply protection rules |" >> $GITHUB_STEP_SUMMARY
                else
                  protection_config=$(cat protection_${branch}.json)
                  payload='{}'
                  
                  if echo "$protection_config" | jq -e '.required_status_checks' >/dev/null 2>&1; then
                    required_status_checks=$(echo "$protection_config" | jq '.required_status_checks')
                    payload=$(echo "$payload" | jq --argjson rsc "$required_status_checks" '. + {required_status_checks: $rsc}')
                  fi
                  
                  enforce_admins=$(echo "$protection_config" | jq -r '.enforce_admins.enabled // false')
                  if [ "$enforce_admins" = "true" ]; then
                    payload=$(echo "$payload" | jq '. + {enforce_admins: true}')
                  fi
                  
                  if echo "$protection_config" | jq -e '.required_pull_request_reviews' >/dev/null 2>&1; then
                    required_pull_request_reviews=$(echo "$protection_config" | jq '.required_pull_request_reviews')
                    payload=$(echo "$payload" | jq --argjson rprr "$required_pull_request_reviews" '. + {required_pull_request_reviews: $rprr}')
                  fi
                  
                  if echo "$protection_config" | jq -e '.restrictions' >/dev/null 2>&1; then
                    restrictions=$(echo "$protection_config" | jq '.restrictions')
                    payload=$(echo "$payload" | jq --argjson rest "$restrictions" '. + {restrictions: $rest}')
                  fi
                  
                  success=false
                  for attempt in $(seq 1 3); do
                    set +e
                    gh api repos/${{ steps.set-target.outputs.target_repo_full }}/branches/$branch/protection \
                      -X PUT \
                      --input <(echo "$payload") 2>/dev/null
                    api_result=$?
                    set -e
                    
                    if [ $api_result -eq 0 ]; then
                      echo "| $branch | PROTECT | SUCCESS |" >> $GITHUB_STEP_SUMMARY
                      protection_success=$((protection_success + 1))
                      success=true
                      break
                    else
                      if [ $attempt -eq 3 ]; then
                        echo "| $branch | PROTECT | FAILED |" >> $GITHUB_STEP_SUMMARY
                        protection_error=$((protection_error + 1))
                      else
                        sleep 3
                      fi
                    fi
                  done
                fi
              else
                echo "| $branch | SKIP | No protection rules in source |" >> $GITHUB_STEP_SUMMARY
              fi
            done < branches_to_protect.txt
          else
            echo "| - | NONE | No branches to protect |" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ inputs.dry_run }}" = "false" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Protection Summary**: $protection_success successful, $protection_error failed" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Copy repository content and settings
        if: inputs.operation == 'create-repo-full' && inputs.dry_run == false && inputs.template_repo != ''
        run: |
          set -e
          echo "Syncing repository content from source to target..."
          
          if [ ! -d "source-repo" ]; then
            echo "Source repository not available, skipping content copy"
            exit 0
          fi
          
          echo "Cloning target repository: ${{ steps.set-target.outputs.target_repo_full }}"
          
          set +e
          gh repo clone "${{ steps.set-target.outputs.target_repo_full }}" target-repo
          clone_result=$?
          set -e
          
          if [ $clone_result -ne 0 ]; then
            echo "Failed to clone target repository, skipping content sync"
            exit 0
          fi
          
          cd target-repo
          
          rsync -av --exclude='.git' ../source-repo/ ./
          
          git config user.name "${{ github.triggering_actor }}"
          git config user.email "${{ github.triggering_actor }}@users.noreply.github.com"
          
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Copy content from source repository ${{ inputs.template_repo }}"
            
            max_attempts=3
            for attempt in $(seq 1 $max_attempts); do
              echo "Content push to master branch attempt $attempt/$max_attempts"
              
              set +e
              git push origin master
              push_result=$?
              set -e
              
              if [ $push_result -eq 0 ]; then
                echo "Content pushed to master branch successfully"
                break
              else
                if [ $attempt -eq $max_attempts ]; then
                  echo "Content push failed after $max_attempts attempts"
                  exit 1
                fi
                sleep 5
              fi
            done
          fi
          cd ..
          
      - name: Update repository README with final status
        if: inputs.operation == 'create-repo-full' && inputs.dry_run == false
        run: |
          set -e
          echo "Updating repository README with final status..."
          
          readme_sha=""
          set +e
          readme_info=$(gh api repos/${{ steps.set-target.outputs.target_repo_full }}/contents/README.md 2>/dev/null)
          readme_result=$?
          set -e
          
          if [ $readme_result -eq 0 ]; then
            readme_sha=$(echo "$readme_info" | jq -r '.sha')
          fi
          
          printf "# %s\n\n" "${{ inputs.target_repo }}" > final_readme.md
          printf "Repository created and configured via GitHub Enterprise Actions workflow\n\n" >> final_readme.md
          printf "## Source Information\n" >> final_readme.md
          printf "- **Source Repository**: %s\n" "${{ inputs.template_repo }}" >> final_readme.md
          printf "- **Created**: %s\n" "$(date)" >> final_readme.md
          printf "- **Workflow**: GitHub Enterprise Repository Management\n" >> final_readme.md
          printf "- **GitHub Enterprise Host**: %s\n" "$GH_HOST" >> final_readme.md
          printf "\n## Configuration Status\n" >> final_readme.md
          printf "- ✅ Repository created successfully\n" >> final_readme.md
          printf "- ✅ Collaborator permissions copied\n" >> final_readme.md
          printf "- ✅ Branch protection rules applied\n" >> final_readme.md
          printf "- ✅ Content synchronized\n" >> final_readme.md
          printf "- ✅ Workflow completed successfully\n" >> final_readme.md
          printf "\n## Summary\n" >> final_readme.md
          printf "This repository was created with the same collaborator permissions, branch protection rules, and content as the source repository. All operations completed with retry logic and comprehensive error handling for GitHub Enterprise environments.\n" >> final_readme.md
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "README update attempt $attempt/$max_attempts"
            
            update_args=()
            update_args+=(-f message="Update README with final configuration status")
            update_args+=(-f content="$(base64 -i final_readme.md)")
            if [ -n "$readme_sha" ]; then
              update_args+=(-f sha="$readme_sha")
            fi
            
            set +e
            gh api repos/${{ steps.set-target.outputs.target_repo_full }}/contents/README.md \
              -X PUT \
              "${update_args[@]}" > /dev/null 2>&1
            update_result=$?
            set -e
            
            if [ $update_result -eq 0 ]; then
              echo "README updated with final status"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                sleep 5
                set +e
                readme_info=$(gh api repos/${{ steps.set-target.outputs.target_repo_full }}/contents/README.md 2>/dev/null)
                readme_result=$?
                set -e
                if [ $readme_result -eq 0 ]; then
                  readme_sha=$(echo "$readme_info" | jq -r '.sha')
                fi
              fi
            fi
          done
          
      - name: Debug and diagnostics
        if: failure()
        run: |
          echo "## Debugging Information" >> $GITHUB_STEP_SUMMARY
          echo "### Environment Variables:" >> $GITHUB_STEP_SUMMARY
          echo "- GH_HOST: $GH_HOST" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub Enterprise connectivity test:" >> $GITHUB_STEP_SUMMARY
          
          set +e
          curl -I "https://$GH_HOST" >/dev/null 2>&1
          curl_result=$?
          set -e
          
          if [ $curl_result -eq 0 ]; then
            echo "  - ✅ Can reach $GH_HOST" >> $GITHUB_STEP_SUMMARY
          else
            echo "  - ❌ Cannot reach $GH_HOST" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### GitHub CLI Status:" >> $GITHUB_STEP_SUMMARY
          
          set +e
          gh auth status >/dev/null 2>&1
          auth_result=$?
          set -e
          
          if [ $auth_result -eq 0 ]; then
            echo "  - ✅ GitHub CLI authenticated" >> $GITHUB_STEP_SUMMARY
          else
            echo "  - ❌ GitHub CLI not authenticated" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### Available GitHub hosts:" >> $GITHUB_STEP_SUMMARY
          gh auth list >> $GITHUB_STEP_SUMMARY 2>&1 || echo "  - No authenticated hosts" >> $GITHUB_STEP_SUMMARY
          
      - name: Final Summary with Enterprise Context
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## GitHub Enterprise Operation Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Operation**: ${{ inputs.operation }}" >> $GITHUB_STEP_SUMMARY
          echo "- **GitHub Enterprise Host**: $GH_HOST" >> $GITHUB_STEP_SUMMARY
          echo "- **Source Repository**: ${{ inputs.template_repo }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Repository**: ${{ steps.set-target.outputs.target_repo_full }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "- **Mode**: DRY RUN" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Mode**: LIVE EXECUTION" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.check-target.outputs.repo_exists }}" = "true" ]; then
            echo "- **Repository Status**: Existed (age: ${{ steps.check-target.outputs.repo_age_minutes }} minutes)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ inputs.dry_run }}" = "false" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Completed Actions:" >> $GITHUB_STEP_SUMMARY
            case "${{ inputs.operation }}" in
              "create-repo-full")
                echo "- ✅ Repository created with GitHub Enterprise support" >> $GITHUB_STEP_SUMMARY
                echo "- ✅ Master branch initialized and pushed" >> $GITHUB_STEP_SUMMARY
                echo "- ✅ Collaborators copied with enterprise authentication" >> $GITHUB_STEP_SUMMARY
                echo "- ✅ Branch protection rules applied with retry logic" >> $GITHUB_STEP_SUMMARY
                echo "- ✅ Content synchronized from source repository" >> $GITHUB_STEP_SUMMARY
                echo "- ✅ Documentation updated with final status" >> $GITHUB_STEP_SUMMARY
                ;;
              "copy-collaborators-only")
                echo "- ✅ Collaborators copied with enterprise authentication" >> $GITHUB_STEP_SUMMARY
                ;;
              "copy-protection-only")
                echo "- ✅ Branch protection rules applied with enterprise support" >> $GITHUB_STEP_SUMMARY
                ;;
              "sync-all-settings")
                echo "- ✅ Collaborators synchronized with enterprise authentication" >> $GITHUB_STEP_SUMMARY
                echo "- ✅ Branch protection rules synchronized with retry logic" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### GitHub Enterprise Features Used:" >> $GITHUB_STEP_SUMMARY
            echo "- Cross-platform GitHub CLI installation" >> $GITHUB_STEP_SUMMARY
            echo "- Enterprise hostname authentication with persistence" >> $GITHUB_STEP_SUMMARY
            echo "- Automatic re-authentication on session loss" >> $GITHUB_STEP_SUMMARY
            echo "- Repository existence validation with age checking" >> $GITHUB_STEP_SUMMARY
            echo "- Comprehensive retry logic for all operations" >> $GITHUB_STEP_SUMMARY
            echo "- Network connectivity validation and diagnostics" >> $GITHUB_STEP_SUMMARY
            echo "- Master branch enforcement (no main branch created)" >> $GITHUB_STEP_SUMMARY
            echo "- Graceful error handling without premature exits" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up temporary files..."
          rm -f collaborators.json source_branches.txt target_branches.txt protected_branches.txt branches_to_protect.txt protection_*.json repo_info.json final_readme.md
          rm -rf source-repo target-repo temp_init 2>/dev/null || true
          echo "Cleanup completed"
