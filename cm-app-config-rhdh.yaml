#!/bin/bash
# Check CTK for VMs in specific folder
CLUSTER_NAME="ocp4prd-dfg"
VM_FOLDER="/ddd/vm/$CLUSTER_NAME"

echo "=== Checking CTK for VMs in folder: $VM_FOLDER ==="
echo ""

govc find "$VM_FOLDER" -type m | while read vm; do
    echo "=== $vm ==="
    govc vm.info -e "$vm" | grep -E "(ctkEnabled|scsi.*ctkEnabled)"
    echo ""
done

#!/bin/bash
# Check CTK for specific cluster
CLUSTER_NAME="ocp4prd-dfg"

govc find . -type m | while read vm; do
    cluster=$(govc vm.info "$vm" | grep "Cluster:" | cut -d: -f2 | tr -d ' ')
    if [[ "$cluster" == "$CLUSTER_NAME" ]]; then
        echo "=== $vm ==="
        govc vm.info -e "$vm" | grep -E "(ctkEnabled|scsi.*ctkEnabled)"
        echo ""
    fi
done


kind: ConfigMap
apiVersion: v1
metadata:
  name: app-config-rhdh
  namespace: demo-project #project-namespace
data:
  app-config-rhdh.yaml: |
    signInPage: guest
    app:
      title: My Red Hat Developer Hub Instance
      baseUrl: ${baseUrl}  # base url is coming from the 'secrets_rdhd-secret.yaml' config in 'setting-up-developer-hub-through-the-operator'
    backend:
      auth:
        keys:
          - secret: ${BACKEND_SECRET}  # BACKEND_SECRET is coming from the 'secrets_rdhd-secret.yaml' config in 'setting-up-developer-hub-through-the-operator'
      baseUrl: ${baseUrl}   # base url is coming from the 'secrets_rdhd-secret.yaml' config in 'setting-up-developer-hub-through-the-operator'
      cors:
        origin: ${baseUrl}   # base url is coming from the 'secrets_rdhd-secret.yaml' config in 'setting-up-developer-hub-through-the-operator'
    integrations:
      github:
        - host: github.com
          #token: <github personal access token>
          apps:
            - appId: ${RHDH_GITHUB_APP_ID}
              clientId: ${RHDH_GITHUB_APP_CLIENT_ID}
              clientSecret: ${RHDH_GITHUB_APP_CLIENT_SECRET}
              webhookUrl: none
              webhookSecret: none
              privateKey: ${RHDH_GITHUB_APP_PRIVATE_KEY}
    catalog:
      providers:
        github:
          # the provider ID can be any camelCase string
          providerId:
            organization: ${RHDH_GITHUB_ORGANIZATION} # the name of the GitHub organization
            catalogPath: '/catalog-info.yaml' # the path where your catalog info file will be placed within projects than need to be scanned
            filters:
              branch: 'master' # string
              repository: '.*' # Regex
            schedule: # optional; same options as in TaskScheduleDefinition
              # supports cron, ISO duration, "human duration" as used in code
              frequency: { minutes: 1 }
              # supports ISO duration, "human duration" as used in code
              timeout: { minutes: 1 }
              initialDelay: { seconds: 15 }
    auth:
      environment: development
      session:
        secret: ${BACKEND_SECRET}
      providers:
        # allow guest authentication for now
        guest:
          dangerouslyAllowOutsideDevelopment: true








apiVersion: v1
kind: ConfigMap
metadata:
  name: my-backstage-config-backend-base-urls
data:
  "app-config.backend-base-urls.yaml": |
    #app:
      # As of 0.6 (RHDH 1.6), this is not needed on OCP by default, but needed on other platforms
    #  baseUrl: https://my-rhdh.example.com
    #backend:
    #  # As of 0.6 (RHDH 1.6), this is not needed on OCP by default, but needed on other platforms
    #  baseUrl: https://my-rhdh.example.com
    #  cors:
    #    # As of 0.6 (RHDH 1.6), this is not needed on OCP by default, but needed on other platforms
    #    origin: https://my-rhdh.example.com

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-backstage-config-backend-auth
data:
  "app-config.backend-auth.yaml": |
    backend:
      auth:
        externalAccess:
          - type: legacy
            options:
              subject: legacy-default-config
              secret: "${BACKEND_SECRET}"
    auth:
      environment: development
      providers:
        guest:
          # using the guest user to query the '/api/dynamic-plugins-info/loaded-plugins' endpoint.
          dangerouslyAllowOutsideDevelopment: true

---
apiVersion: v1
kind: Secret
metadata:
  name: my-backstage-backend-auth-secret
stringData:
  # generated with the command below (from https://backstage.io/docs/auth/service-to-service-auth/#setup):
  # node -p 'require("crypto").randomBytes(24).toString("base64")'
  BACKEND_SECRET: "R2FxRVNrcmwzYzhhN3l0V1VRcnQ3L1pLT09WaVhDNUEK" # notsecret

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-backstage-config-cm1
data:
  app-config1-cm1.db.yaml: |
    backend:
      database:
        connection:
          password: ${POSTGRESQL_PASSWORD}
          user: ${POSTGRESQL_USER}
  app-config2-cm1.yaml: |
    # Some comment in this file
  app-config3-cm1.odo.yaml: |
    catalog:
      locations:
        - type: url
          target: https://github.com/ododev/odo-backstage-software-template/blob/main/template.yaml
          rules:
            - allow: [Template]
    # # catalog.providers.githubOrg.default.orgUrl

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-backstage-config-cm2
data:
  app-config1-cm2.gh.yaml: |
    auth:
      # see https://backstage.io/docs/auth/ to learn about auth providers
      environment: development
      providers:
        github:
          development:
            clientId: '${GH_CLIENT_ID}'
            clientSecret: '${GH_CLIENT_SECRET}'
  app-config2-cm2.yaml: |
    # a comment

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-dynamic-plugins-config-cm
data:
  dynamic-plugins.yaml: |
    includes:
      - dynamic-plugins.default.yaml
    plugins:
      - package: ./dynamic-plugins/dist/roadiehq-scaffolder-backend-module-utils-dynamic
        disabled: false
      - package: './dynamic-plugins/dist/backstage-plugin-catalog-backend-module-github-dynamic'
        disabled: false
        pluginConfig:
          catalog:
            providers:
              github:
                myorg:
                  organization: '${GITHUB_ORG}'
                  schedule:
                    # supports cron, ISO duration, "human duration" (used below)
                    frequency: { minutes: 30}
                    # supports ISO duration, "human duration (used below)
                    timeout: { minutes: 3}
                    initialDelay: { seconds: 15}
      - package: ./dynamic-plugins/dist/backstage-plugin-techdocs-backend-dynamic
        disabled: false
        pluginConfig:
          # Reference documentation https://backstage.io/docs/features/techdocs/configuration
          # Note: After experimenting with basic setup, use CI/CD to generate docs
          # and an external cloud storage when deploying TechDocs for production use-case.
          # https://backstage.io/docs/features/techdocs/how-to-guides#how-to-migrate-from-techdocs-basic-to-recommended-deployment-approach
          techdocs:
            builder: local
            generator:
              runIn: local
            publisher:
              type: local
      - package: ./dynamic-plugins/dist/backstage-plugin-catalog-backend-module-gitlab-dynamic
        disabled: false
        pluginConfig:
          catalog:
            providers:
              gitlab: {}

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-env-cm-1
data:
  CM_ENV1: "cm env 1"
  CM_ENV2: "cm env 2"

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-env-cm-11
data:
  CM_ENV11: "cm env 11"
  CM_ENV12: "cm env 12"

---
apiVersion: v1
kind: Secret
metadata:
  name: my-gh-auth-secret
stringData:
  GH_CLIENT_ID: "my GH client ID"
  GH_CLIENT_SECRET: "my GH client secret"

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-backstage-extra-files-cm1
data:
  cm_file1.txt: |
    # From ConfigMap
    Lorem Ipsum
    Dolor Sit Amet
  cm_file2.properties: |
    conf.x=y
    conf.y=z

---
apiVersion: v1
kind: Secret
metadata:
  name: my-backstage-extra-files-secret1
stringData:
  secret_file1.txt: |
    # From Secret
    Lorem Ipsum
    Dolor Sit Amet
  secret_file2.properties: |
    sec.a=b
    sec.b=c
  secrets.prod.yaml: |
    appId: 1
    webhookUrl: https://smee.io/foo
    clientId: someGithubAppClientId
    clientSecret: someGithubAppClientSecret
    webhookSecret: someWebhookSecret
    privateKey: |
      SomeRsaPrivateKey

---
apiVersion: rhdh.redhat.com/v1alpha4
kind: Backstage
metadata:
  name: bs-app-config
spec:
  database:
    enableLocalDb: true
  deployment:
    patch:
      spec:
        replicas: 1
  application:
    appConfig:
      configMaps:
        - name: "my-backstage-config-backend-base-urls"
        - name: "my-backstage-config-backend-auth"
        - name: "my-backstage-config-cm1"
        - name: "my-backstage-config-cm2"
          key: "app-config1-cm2.gh.yaml"
    dynamicPluginsConfigMapName: "my-dynamic-plugins-config-cm"
    extraFiles:
      mountPath: /tmp/my-extra-files
      configMaps:
        - name: "my-backstage-extra-files-cm1"
      secrets:
        - name: "my-backstage-extra-files-secret1"
          key: secret_file1.txt
    extraEnvs:
      envs:
        - name: GITHUB_ORG
          value: 'my-gh-org'
        - name: MY_ENV_VAR_2
          value: my-value-2
      configMaps:
        - name: my-env-cm-1
        - name: my-env-cm-11
          key: CM_ENV11
      secrets:
        - name: "my-backstage-backend-auth-secret"
          key: BACKEND_SECRET
        - name: my-gh-auth-secret





First, Extract Credentials from OpenShift Secret
bash# Extract vCenter credentials from OpenShift secret
export GOVC_URL=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.server}' | base64 -d)
export GOVC_USERNAME=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.username}' | base64 -d)
export GOVC_PASSWORD=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.password}' | base64 -d)
export GOVC_INSECURE=true  # Usually needed for OpenShift vSphere setups

# Verify connection
govc about
Alternative: One-liner Setup
bash# Set all govc environment variables in one command
eval $(oc get secret vsphere-creds -n openshift-config -o json | jq -r '.data | to_entries[] | "export GOVC_" + (.key | ascii_upcase | gsub("\\."; "_")) + "=" + (.value | @base64d)')
export GOVC_INSECURE=true
Check VMs Missing CTK Options
bash# List all VMs and check for CTK configuration
echo "=== VMs Missing CTK Configuration ==="
govc find . -type m | while read vm; do
    vm_name=$(basename "$vm")
    echo "Checking: $vm_name"
    
    # Get extra config for the VM
    ctk_main=$(govc vm.info -e "$vm" 2>/dev/null | grep "^ctkEnabled:" | cut -d: -f2 | tr -d ' ')
    ctk_scsi=$(govc vm.info -e "$vm" 2>/dev/null | grep "^scsi0:0.ctkEnabled:" | cut -d: -f2 | tr -d ' ')
    
    # Check if CTK is missing or not set to TRUE
    if [[ "$ctk_main" != "TRUE" ]] || [[ "$ctk_scsi" != "TRUE" ]]; then
        echo "❌ VM: $vm_name"
        echo "   ctkEnabled: ${ctk_main:-MISSING}"
        echo "   scsi0:0.ctkEnabled: ${ctk_scsi:-MISSING}"
        echo "   ---"
    fi
done
More Comprehensive CTK Check Script
bash#!/bin/bash
# Script: check_ctk_status.sh

# Setup govc credentials from OpenShift
setup_govc() {
    echo "Setting up govc credentials from OpenShift secret..."
    export GOVC_URL=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.server}' | base64 -d)
    export GOVC_USERNAME=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.username}' | base64 -d)
    export GOVC_PASSWORD=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.password}' | base64 -d)
    export GOVC_INSECURE=true
    
    # Test connection
    if ! govc about >/dev/null 2>&1; then
        echo "Failed to connect to vCenter"
        exit 1
    fi
    echo "Connected to vCenter: $GOVC_URL"
}

# Check CTK status for all VMs
check_ctk_status() {
    echo -e "\n=== CTK Status Report ==="
    echo -e "VM Name\t\t\t\tctkEnabled\tscsi0:0.ctkEnabled\tStatus"
    echo -e "-------\t\t\t\t----------\t----------------\t------"
    
    govc find . -type m | while read vm; do
        vm_name=$(basename "$vm")
        
        # Get VM extra configuration
        vm_config=$(govc vm.info -e "$vm" 2>/dev/null)
        ctk_main=$(echo "$vm_config" | grep "^ctkEnabled:" | cut -d: -f2 | tr -d ' ')
        ctk_scsi=$(echo "$vm_config" | grep "^scsi0:0.ctkEnabled:" | cut -d: -f2 | tr -d ' ')
        
        # Determine status
        if [[ "$ctk_main" == "TRUE" ]] && [[ "$ctk_scsi" == "TRUE" ]]; then
            status="✅ ENABLED"
        elif [[ -n "$ctk_main" ]] || [[ -n "$ctk_scsi" ]]; then
            status="⚠️  PARTIAL"
        else
            status="❌ MISSING"
        fi
        
        printf "%-30s\t%-10s\t%-16s\t%s\n" \
            "$vm_name" \
            "${ctk_main:-MISSING}" \
            "${ctk_scsi:-MISSING}" \
            "$status"
    done
}

# Main execution
setup_govc
check_ctk_status
Filter for OpenShift Worker Nodes Only
bash# Check CTK status specifically for OpenShift worker nodes
echo "=== OpenShift Worker Nodes CTK Status ==="
govc find . -type m | grep -E "(worker|rhcos)" | while read vm; do
    vm_name=$(basename "$vm")
    
    # Get power state
    power_state=$(govc vm.info "$vm" | grep "Power state:" | cut -d: -f2 | tr -d ' ')
    
    # Get CTK configuration
    ctk_main=$(govc vm.info -e "$vm" 2>/dev/null | grep "^ctkEnabled:" | cut -d: -f2 | tr -d ' ')
    ctk_scsi=$(govc vm.info -e "$vm" 2>/dev/null | grep "^scsi0:0.ctkEnabled:" | cut -d: -f2 | tr -d ' ')
    
    if [[ "$ctk_main" != "TRUE" ]] || [[ "$ctk_scsi" != "TRUE" ]]; then
        echo "Worker Node: $vm_name (Power: $power_state)"
        echo "  ctkEnabled: ${ctk_main:-MISSING}"
        echo "  scsi0:0.ctkEnabled: ${ctk_scsi:-MISSING}"
        echo "  Host: $(govc vm.info "$vm" | grep "Host:" | cut -d: -f2 | tr -d ' ')"
        echo "  ---"
    fi
done
Export Results to File
bash# Create detailed report and save to file
{
    echo "CTK Status Report - $(date)"
    echo "=================================="
    echo ""
    
    govc find . -type m | while read vm; do
        vm_name=$(basename "$vm")
        vm_info=$(govc vm.info "$vm")
        vm_config=$(govc vm.info -e "$vm" 2>/dev/null)
        
        power_state=$(echo "$vm_info" | grep "Power state:" | cut -d: -f2 | tr -d ' ')
        host=$(echo "$vm_info" | grep "Host:" | cut -d: -f2 | tr -d ' ')
        ctk_main=$(echo "$vm_config" | grep "^ctkEnabled:" | cut -d: -f2 | tr -d ' ')
        ctk_scsi=$(echo "$vm_config" | grep "^scsi0:0.ctkEnabled:" | cut -d: -f2 | tr -d ' ')
        
        if [[ "$ctk_main" != "TRUE" ]] || [[ "$ctk_scsi" != "TRUE" ]]; then
            echo "VM: $vm_name"
            echo "  Power State: $power_state"
            echo "  Host: $host"
            echo "  ctkEnabled: ${ctk_main:-MISSING}"
            echo "  scsi0:0.ctkEnabled: ${ctk_scsi:-MISSING}"
            echo ""
        fi
    done
} > ctk_missing_report.txt

echo "Report saved to ctk_missing_report.txt"
Quick Commands Summary
bash# 1. Setup credentials
export GOVC_URL=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.server}' | base64 -d)
export GOVC_USERNAME=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.username}' | base64 -d)
export GOVC_PASSWORD=$(oc get secret vsphere-creds -n openshift-config -o jsonpath='{.data.vcenter\.password}' | base64 -d)
export GOVC_INSECURE=true

# 2. Test connection
govc about

# 3. Quick CTK check
govc find . -type m | xargs -I {} sh -c 'echo "=== {} ==="; govc vm.info -e "{}" | grep -E "(ctkEnabled|scsi.*ctkEnabled)"'
Note: Make sure you have:

oc CLI tool configured and logged into your OpenShift cluster
govc CLI tool installed
jq and base64 utilities available
Proper permissions to access the vsphere-creds secret in the openshift-config namespace

The secret is typically in openshift-config namespace, but if it's in a different namespace in your setup, adjust the namespace accordingly.

