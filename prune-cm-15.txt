#!/bin/bash

# Extract Error from Failed Pod
# The pod shows "Error" status - need to get the actual failure reason

NS="configmap-secret-pruner"

echo "=========================================="
echo "Extracting Error from Failed Pod"
echo "=========================================="

# Get the failed pod
POD=$(oc get pods -n "$NS" --no-headers | grep "Error" | head -1 | awk '{print $1}')

if [[ -z "$POD" ]]; then
  echo "No Error pod found. Checking for other states..."
  oc get pods -n "$NS"
  exit 1
fi

echo "Failed Pod: $POD"
echo ""

# Get the exit code
echo "--- Exit Code ---"
EXIT_CODE=$(oc get pod "$POD" -n "$NS" -o jsonpath='{.status.containerStatuses[0].state.terminated.exitCode}' 2>/dev/null)
echo "Exit Code: $EXIT_CODE"
echo ""

# Get the reason
echo "--- Termination Reason ---"
REASON=$(oc get pod "$POD" -n "$NS" -o jsonpath='{.status.containerStatuses[0].state.terminated.reason}' 2>/dev/null)
echo "Reason: $REASON"
echo ""

# Get the full logs (this will show the actual error)
echo "--- Full Pod Logs ---"
oc logs -n "$NS" "$POD" 2>&1
echo ""

# Get last 20 lines specifically
echo "--- Last 20 Lines ---"
oc logs -n "$NS" "$POD" --tail=20 2>&1
echo ""

# Check for common bash errors
echo "--- Checking for Common Errors ---"
oc logs -n "$NS" "$POD" 2>&1 | grep -i "line.*command not found\|syntax error\|unexpected\|No such file\|permission denied" | head -10
echo ""

# Describe pod for events
echo "--- Pod Events ---"
oc describe pod "$POD" -n "$NS" | grep -A20 "Events:"
echo ""

echo "=========================================="
echo "Error Analysis Complete"
echo "=========================================="





apiVersion: batch/v1
kind: CronJob
metadata:
  name: cm-secret-pruner
  namespace: configmap-secret-pruner
spec:
  schedule: "0 2 * * 0"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 0
      template:
        metadata:
          labels:
            app: cm-secret-pruner
        spec:
          serviceAccountName: cm-secret-pruner
          restartPolicy: Never
          containers:
          - name: pruner
            image: image-registry.openshift-image-registry.svc:5000/openshift/cli:latest
            resources:
              requests:
                memory: "512Mi"
                cpu: "250m"
              limits:
                memory: "2Gi"
                cpu: "1000m"
            env:
            - name: TZ
              value: "America/New_York"
            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail
              
              # ========================================
              # ConfigMap and Secret Pruner v2.0
              # Updated: November 27, 2024
              # 
              # CRITICAL FIXES IMPLEMENTED:
              # 1. ‚úÖ Fixed multi-line parsing bug (head -1 issue)
              # 2. ‚úÖ Fixed projected volume extraction (select .configMap)
              # 3. ‚úÖ Added grep -F for safer string matching
              # 4. ‚úÖ Added temp file cleanup trap
              # 5. ‚úÖ Added time-based pagination safety
              # ========================================
              
              NS="configmap-secret-pruner"
              CM="cm-secret-pruner-config"
              
              # ========================================
              # Global Temp File Cleanup
              # ========================================
              TEMP_FILES=()
              
              cleanup_temp_files() {
                if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
                  rm -f "${TEMP_FILES[@]}" 2>/dev/null || true
                fi
              }
              
              trap cleanup_temp_files EXIT
              
              # ========================================
              # Logging Function
              # ========================================
              log() {
                local level="$1"
                shift
                local message="$*"
                local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                printf "[%s] [%s] %s\n" "$timestamp" "$level" "$message"
              }
              
              error_exit() {
                log ERROR "$1"
                exit 1
              }
              
              # ========================================
              # Configuration Loading
              # ========================================
              log INFO "ConfigMap Pruner v2.0 - Starting"
              log INFO "Loading configuration from ConfigMap: $CM"
              
              get_config() {
                local key="$1"
                local default="$2"
                local value=$(oc get cm "$CM" -n "$NS" -o jsonpath="{.data.$key}" 2>/dev/null || echo "")
                echo "${value:-$default}"
              }
              
              DRY_RUN=$(get_config "dryRun" "true")
              MIN_AGE=$(get_config "minAge" "7")
              RATE_LIMIT_NS_DELAY=$(get_config "rateLimitNsDelay" "0.1")
              RATE_LIMIT_DEL_DELAY=$(get_config "rateLimitDelDelay" "0.5")
              RATE_LIMIT_BATCH=$(get_config "rateLimitBatch" "10")
              RATE_LIMIT_PAUSE=$(get_config "rateLimitPause" "0.5")
              
              PROCESS_HIGH_VOLUME=$(get_config "processHighVolumeNamespaces" "true")
              PROCESS_ONLY_HIGH_VOLUME=$(get_config "processOnlyHighVolume" "false")
              HIGH_VOLUME_THRESHOLD=$(get_config "highVolumeThreshold" "1000")
              PAGINATION_LIMIT=$(get_config "paginationLimit" "500")
              
              MAX_NS_DURATION=$(get_config "maxNamespaceDuration" "600")
              WARN_PAGINATION_PAGES=$(get_config "warnPaginationPages" "100")
              ERROR_PAGINATION_PAGES=$(get_config "errorPaginationPages" "200")
              
              ENABLE_DEBUG=$(get_config "enableDebugLogging" "false")
              
              log INFO "Rate Limiting: ns_delay=${RATE_LIMIT_NS_DELAY}s del_delay=${RATE_LIMIT_DEL_DELAY}s batch=$RATE_LIMIT_BATCH pause=${RATE_LIMIT_PAUSE}s"
              log INFO "Config: DRY_RUN=$DRY_RUN MIN_AGE=$MIN_AGE days THRESHOLD=$HIGH_VOLUME_THRESHOLD"
              log INFO "Config: PROCESS_HIGH_VOLUME=$PROCESS_HIGH_VOLUME PROCESS_ONLY_HIGH_VOLUME=$PROCESS_ONLY_HIGH_VOLUME"
              log INFO "Config: MAX_NS_DURATION=${MAX_NS_DURATION}s PAGINATION_LIMIT=$PAGINATION_LIMIT"
              
              # ========================================
              # Exclusion Lists
              # ========================================
              excluded_namespaces=$(get_config "excludedNamespaces" "")
              excluded_cm_names=$(get_config "excludedConfigMapNames" "")
              
              # ========================================
              # Resource Type Detection (Robust)
              # ========================================
              log INFO "Detecting available API resources..."
              
              HAS_DEPLOYMENTS=0
              HAS_STATEFULSETS=0
              HAS_DAEMONSETS=0
              HAS_REPLICASETS=0
              HAS_REPLICATIONCONTROLLERS=0
              HAS_DEPLOYMENTCONFIGS=0
              HAS_CRONJOBS=0
              HAS_JOBS=0
              
              while IFS= read -r line; do
                resource=$(echo "$line" | awk '{print $1}')
                case "$resource" in
                  deployments) HAS_DEPLOYMENTS=1 ;;
                  statefulsets) HAS_STATEFULSETS=1 ;;
                  daemonsets) HAS_DAEMONSETS=1 ;;
                  replicasets) HAS_REPLICASETS=1 ;;
                  replicationcontrollers) HAS_REPLICATIONCONTROLLERS=1 ;;
                  deploymentconfigs) HAS_DEPLOYMENTCONFIGS=1 ;;
                  cronjobs) HAS_CRONJOBS=1 ;;
                  jobs) HAS_JOBS=1 ;;
                esac
              done < <(oc api-resources --no-headers 2>/dev/null | grep -E "^(deployments|statefulsets|daemonsets|replicasets|replicationcontrollers|deploymentconfigs|cronjobs|jobs)" || true)
              
              log INFO "Available workload types: deploy=$HAS_DEPLOYMENTS sts=$HAS_STATEFULSETS ds=$HAS_DAEMONSETS rs=$HAS_REPLICASETS rc=$HAS_REPLICATIONCONTROLLERS dc=$HAS_DEPLOYMENTCONFIGS cronjob=$HAS_CRONJOBS job=$HAS_JOBS"
              
              # ========================================
              # Workload Reference Fetching
              # ========================================
              fetch_workload_safe() {
                local resource_type="$1"
                local ns="$2"
                oc get "$resource_type" -n "$ns" -o json 2>/dev/null || echo '{"items":[]}'
              }
              
              get_workload_references() {
                local ns="$1"
                
                local f_deploy=$(mktemp)
                TEMP_FILES+=("$f_deploy")
                local f_sts=$(mktemp)
                TEMP_FILES+=("$f_sts")
                local f_ds=$(mktemp)
                TEMP_FILES+=("$f_ds")
                local f_rs=$(mktemp)
                TEMP_FILES+=("$f_rs")
                local f_cronjob=$(mktemp)
                TEMP_FILES+=("$f_cronjob")
                local f_job=$(mktemp)
                TEMP_FILES+=("$f_job")
                local f_pod=$(mktemp)
                TEMP_FILES+=("$f_pod")
                local f_rc=$(mktemp)
                TEMP_FILES+=("$f_rc")
                local f_dc=$(mktemp)
                TEMP_FILES+=("$f_dc")
                local f_merged=$(mktemp)
                TEMP_FILES+=("$f_merged")
                
                echo '{"items":[]}' > "$f_deploy"
                echo '{"items":[]}' > "$f_sts"
                echo '{"items":[]}' > "$f_ds"
                echo '{"items":[]}' > "$f_rs"
                echo '{"items":[]}' > "$f_cronjob"
                echo '{"items":[]}' > "$f_job"
                echo '{"items":[]}' > "$f_pod"
                echo '{"items":[]}' > "$f_rc"
                echo '{"items":[]}' > "$f_dc"
                
                [[ "$HAS_DEPLOYMENTS" == "1" ]] && fetch_workload_safe "deployments.apps" "$ns" > "$f_deploy"
                [[ "$HAS_STATEFULSETS" == "1" ]] && fetch_workload_safe "statefulsets.apps" "$ns" > "$f_sts"
                [[ "$HAS_DAEMONSETS" == "1" ]] && fetch_workload_safe "daemonsets.apps" "$ns" > "$f_ds"
                [[ "$HAS_REPLICASETS" == "1" ]] && fetch_workload_safe "replicasets.apps" "$ns" > "$f_rs"
                [[ "$HAS_CRONJOBS" == "1" ]] && fetch_workload_safe "cronjobs.batch" "$ns" > "$f_cronjob"
                [[ "$HAS_JOBS" == "1" ]] && fetch_workload_safe "jobs.batch" "$ns" > "$f_job"
                fetch_workload_safe "pods" "$ns" > "$f_pod"
                [[ "$HAS_REPLICATIONCONTROLLERS" == "1" ]] && fetch_workload_safe "replicationcontrollers" "$ns" > "$f_rc"
                [[ "$HAS_DEPLOYMENTCONFIGS" == "1" ]] && fetch_workload_safe "deploymentconfigs.apps.openshift.io" "$ns" > "$f_dc"
                
                if ! jq -s '{items: ([.[] | .items // []] | add)}' \
                  "$f_deploy" "$f_sts" "$f_ds" "$f_rs" "$f_cronjob" "$f_job" "$f_pod" "$f_rc" "$f_dc" \
                  > "$f_merged" 2>/dev/null; then
                  log WARN "Failed to merge workloads in $ns"
                  rm -f "$f_deploy" "$f_sts" "$f_ds" "$f_rs" "$f_cronjob" "$f_job" "$f_pod" "$f_rc" "$f_dc" "$f_merged"
                  echo ""
                  echo ""
                  return
                fi
                
                # FIX #2: Projected volume extraction with select(.configMap)
                refs=$(jq -r '
                  [
                    .items[]? | 
                    (
                      (select(.kind == "Deployment" or .kind == "StatefulSet" or .kind == "DaemonSet" or .kind == "ReplicaSet" or .kind == "ReplicationController") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                          (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "Pod") |
                        .spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                          (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "CronJob") |
                        .spec.jobTemplate.spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "Job") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "DeploymentConfig") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      )
                    )
                  ] | unique | .[]
                ' "$f_merged" 2>/dev/null || echo "")
                
                details=$(jq -r '
                  .items[]? |
                  . as $workload |
                  (
                    (select(.kind == "Deployment" or .kind == "StatefulSet" or .kind == "DaemonSet" or .kind == "ReplicaSet" or .kind == "ReplicationController") |
                      .spec.template.spec | (
                        (.volumes[]?.configMap?.name // empty),
                        (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                        (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                        (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                      )
                    ),
                    (select(.kind == "Pod") |
                      .spec | (
                        (.volumes[]?.configMap?.name // empty),
                        (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                        (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                        (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                      )
                    ),
                    (select(.kind == "CronJob") |
                      .spec.jobTemplate.spec.template.spec | (
                        (.volumes[]?.configMap?.name // empty),
                        (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                        (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                      )
                    ),
                    (select(.kind == "Job") |
                      .spec.template.spec | (
                        (.volumes[]?.configMap?.name // empty),
                        (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                        (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                      )
                    ),
                    (select(.kind == "DeploymentConfig") |
                      .spec.template.spec | (
                        (.volumes[]?.configMap?.name // empty),
                        (.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name // empty),
                        (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                        (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                      )
                    )
                  ) |
                  . as $cmname |
                  ($workload.kind | ascii_downcase) as $kind |
                  "\($cmname):\($kind):\($workload.metadata.name)"
                ' "$f_merged" 2>/dev/null || echo "")
                
                rm -f "$f_deploy" "$f_sts" "$f_ds" "$f_rs" "$f_cronjob" "$f_job" "$f_pod" "$f_rc" "$f_dc" "$f_merged"
                
                # FIX #1: Delimiter-based multi-line parsing
                echo "---REFS-START---"
                echo "$refs"
                echo "---REFS-END---"
                echo "$details"
              }
              
              # ========================================
              # Main Processing Logic
              # ========================================
              
              current_epoch=$(date +%s)
              min_age_seconds=$((MIN_AGE * 86400))
              
              total_deleted=0
              total_protected=0
              total_referenced=0
              total_too_new=0
              total_timeouts=0
              
              all_namespaces=$(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
              
              if [[ -z "$all_namespaces" ]]; then
                error_exit "Failed to retrieve namespaces or no namespaces found"
              fi
              
              namespace_count=$(echo "$all_namespaces" | wc -w)
              log INFO "Found $namespace_count namespaces in cluster"
              
              namespaces_excluded=0
              for ns in $all_namespaces; do
                if echo "$excluded_namespaces" | grep -qxF "$ns"; then
                  ((namespaces_excluded++))
                fi
              done
              
              log INFO "Excluded $namespaces_excluded namespace(s) from processing"
              
              namespaces_processed=0
              batch_count=0
              
              for ns in $all_namespaces; do
                if echo "$excluded_namespaces" | grep -qxF "$ns"; then
                  continue
                fi
                
                ((namespaces_processed++))
                ((batch_count++))
                
                if [[ $batch_count -ge $RATE_LIMIT_BATCH ]]; then
                  sleep "$RATE_LIMIT_PAUSE"
                  batch_count=0
                fi
                
                sleep "$RATE_LIMIT_NS_DELAY"
                
                log INFO "-----------------------------------------------"
                log INFO "Processing Namespace [$namespaces_processed/$((namespace_count - namespaces_excluded))]: $ns"
                log INFO "-----------------------------------------------"
                
                cm_count=0
                cm_count=$(oc get cm -n "$ns" --no-headers 2>/dev/null | wc -l || echo 0)
                
                if [[ $cm_count -eq 0 ]]; then
                  continue
                fi
                
                log INFO "Found $cm_count ConfigMap(s)"
                
                is_high_volume=false
                if [[ $cm_count -ge $HIGH_VOLUME_THRESHOLD ]]; then
                  is_high_volume=true
                  log INFO "High-volume namespace detected ($cm_count ConfigMaps >= $HIGH_VOLUME_THRESHOLD threshold)"
                fi
                
                if [[ "$PROCESS_ONLY_HIGH_VOLUME" == "true" ]] && [[ "$is_high_volume" != "true" ]]; then
                  log INFO "Skipping non-high-volume namespace (PROCESS_ONLY_HIGH_VOLUME=true)"
                  continue
                fi
                
                if [[ "$is_high_volume" == "true" ]] && [[ "$PROCESS_HIGH_VOLUME" == "false" ]]; then
                  log INFO "Skipping high-volume namespace (PROCESS_HIGH_VOLUME=false)"
                  continue
                fi
                
                if [[ "$is_high_volume" == "true" ]] && [[ "$PROCESS_HIGH_VOLUME" == "true" ]]; then
                  log INFO "Processing high-volume namespace with pagination (limit=$PAGINATION_LIMIT)"
                  
                  local start_ns_time=$(date +%s)
                  local page_num=0
                  local continue_token=""
                  local deleted_in_ns=0
                  
                  # FIX #1: Use delimiter-based parsing
                  ref_result=$(get_workload_references "$ns")
                  referenced_cms=$(echo "$ref_result" | sed -n '/---REFS-START---/,/---REFS-END---/p' | grep -v "^---REFS-" || echo "")
                  workload_details=$(echo "$ref_result" | sed -n '/---REFS-END---/,$p' | tail -n +2 || echo "")
                  
                  while true; do
                    ((page_num++))
                    
                    # FIX #5: Time-based safety instead of page limit
                    local current_time=$(date +%s)
                    local elapsed=$((current_time - start_ns_time))
                    
                    if [[ $elapsed -gt $MAX_NS_DURATION ]]; then
                      log ERROR "TIMEOUT: Namespace $ns exceeded $MAX_NS_DURATION seconds"
                      log ERROR "Processed approximately $((page_num * PAGINATION_LIMIT)) ConfigMaps"
                      log ERROR "Namespace may require manual review or increase maxNamespaceDuration"
                      ((total_timeouts++))
                      break
                    fi
                    
                    # Informational warnings (not limits)
                    if [[ $page_num -eq $WARN_PAGINATION_PAGES ]]; then
                      log WARN "Namespace $ns: Processed $WARN_PAGINATION_PAGES pages ($((page_num * PAGINATION_LIMIT)) ConfigMaps so far)"
                    fi
                    
                    if [[ $page_num -eq $ERROR_PAGINATION_PAGES ]]; then
                      log ERROR "Namespace $ns: Processed $ERROR_PAGINATION_PAGES pages - extremely large namespace, still processing..."
                    fi
                    
                    if [[ -n "$continue_token" ]]; then
                      cm_json=$(oc get cm -n "$ns" --limit="$PAGINATION_LIMIT" --continue="$continue_token" -o json 2>/dev/null || echo '{"items":[]}')
                    else
                      cm_json=$(oc get cm -n "$ns" --limit="$PAGINATION_LIMIT" -o json 2>/dev/null || echo '{"items":[]}')
                    fi
                    
                    if ! echo "$cm_json" | jq empty 2>/dev/null; then
                      log WARN "Invalid JSON response for ConfigMaps in $ns (page $page_num), skipping"
                      break
                    fi
                    
                    local page_cm_count=$(echo "$cm_json" | jq -r '.items | length' 2>/dev/null || echo 0)
                    
                    if [[ $page_cm_count -eq 0 ]]; then
                      break
                    fi
                    
                    while IFS='|' read -r name creation_timestamp annotations labels; do
                      [[ -z "$name" ]] && continue
                      
                      # FIX #3: Use grep -Fxq for safer string matching
                      if echo "$excluded_cm_names" | grep -Fxq "$name"; then
                        ((total_protected++))
                        log INFO "SKIPPED (excluded): $name"
                        continue
                      fi
                      
                      if [[ "$name" =~ ^(kube-root-ca\.crt|openshift-service-ca\.crt|istio-ca-root-cert|openshift-ca\.crt)$ ]]; then
                        ((total_protected++))
                        log INFO "SKIPPED (system): $name"
                        continue
                      fi
                      
                      if echo "$annotations" | grep -q "service.beta.openshift.io/inject-cabundle\|service.alpha.openshift.io/inject-cabundle"; then
                        ((total_protected++))
                        log INFO "SKIPPED (CA bundle): $name"
                        continue
                      fi
                      
                      if echo "$labels" | grep -q "config.openshift.io/inject-trusted-cabundle"; then
                        ((total_protected++))
                        log INFO "SKIPPED (trusted CA): $name"
                        continue
                      fi
                      
                      if echo "$labels" | grep -q "app.kubernetes.io/managed-by.*argocd\|app.kubernetes.io/managed-by.*Helm\|meta.helm.sh/release-name"; then
                        ((total_protected++))
                        log INFO "SKIPPED (GitOps/Helm): $name"
                        continue
                      fi
                      
                      if echo "$labels" | grep -q "prune.protected.*true"; then
                        ((total_protected++))
                        log INFO "SKIPPED (protected label): $name"
                        continue
                      fi
                      
                      created_epoch=$(date -d "$creation_timestamp" +%s 2>/dev/null || echo "$current_epoch")
                      age_seconds=$((current_epoch - created_epoch))
                      
                      if [[ $age_seconds -lt $min_age_seconds ]]; then
                        ((total_too_new++))
                        continue
                      fi
                      
                      # FIX #3: Use printf and grep -Fxq for safer matching
                      if printf '%s\n' "$referenced_cms" | grep -Fxq "$name"; then
                        ((total_referenced++))
                        
                        workload_ref=$(echo "$workload_details" | grep "^$name:" | head -1 | cut -d: -f2- || echo "unknown")
                        log INFO "REFERENCED: $name (by: $workload_ref)"
                        continue
                      fi
                      
                      if [[ "$DRY_RUN" == "false" ]]; then
                        if oc delete cm "$name" -n "$ns" 2>/dev/null; then
                          ((total_deleted++))
                          ((deleted_in_ns++))
                          log INFO "DELETED: $name (age: $((age_seconds / 86400)) days, unreferenced)"
                          sleep "$RATE_LIMIT_DEL_DELAY"
                        else
                          log WARN "Failed to delete ConfigMap: $name in $ns"
                        fi
                      else
                        ((total_deleted++))
                        ((deleted_in_ns++))
                        log INFO "DRY-RUN: Would delete $name (age: $((age_seconds / 86400)) days, unreferenced)"
                      fi
                    done < <(echo "$cm_json" | jq -r '.items[] | "\(.metadata.name)|\(.metadata.creationTimestamp)|\(.metadata.annotations // {})|\(.metadata.labels // {})"' 2>/dev/null)
                    
                    continue_token=$(echo "$cm_json" | jq -r '.metadata.continue // empty')
                    
                    if [[ -z "$continue_token" ]]; then
                      break
                    fi
                  done
                  
                  log INFO "Namespace $ns: Processed $page_num pages, deleted $deleted_in_ns ConfigMap(s)"
                  
                else
                  # Normal processing (non-high-volume namespaces)
                  ref_result=$(get_workload_references "$ns")
                  referenced_cms=$(echo "$ref_result" | sed -n '/---REFS-START---/,/---REFS-END---/p' | grep -v "^---REFS-" || echo "")
                  workload_details=$(echo "$ref_result" | sed -n '/---REFS-END---/,$p' | tail -n +2 || echo "")
                  
                  cm_json=""
                  cm_json=$(oc get cm -n "$ns" -o json 2>/dev/null || echo '{"items":[]}')
                  
                  if ! echo "$cm_json" | jq empty 2>/dev/null; then
                    log WARN "Invalid JSON response for ConfigMaps in $ns, skipping namespace"
                    continue
                  fi
                  
                  skipped_count=0
                  deleted_count=0
                  
                  while IFS='|' read -r name creation_timestamp annotations labels; do
                    [[ -z "$name" ]] && continue
                    
                    if echo "$excluded_cm_names" | grep -Fxq "$name"; then
                      ((skipped_count++))
                      ((total_protected++))
                      log INFO "SKIPPED (excluded): $name"
                      continue
                    fi
                    
                    if [[ "$name" =~ ^(kube-root-ca\.crt|openshift-service-ca\.crt|istio-ca-root-cert|openshift-ca\.crt)$ ]]; then
                      ((skipped_count++))
                      ((total_protected++))
                      log INFO "SKIPPED (system): $name"
                      continue
                    fi
                    
                    if echo "$annotations" | grep -q "service.beta.openshift.io/inject-cabundle\|service.alpha.openshift.io/inject-cabundle"; then
                      ((skipped_count++))
                      ((total_protected++))
                      log INFO "SKIPPED (CA bundle): $name"
                      continue
                    fi
                    
                    if echo "$labels" | grep -q "config.openshift.io/inject-trusted-cabundle"; then
                      ((skipped_count++))
                      ((total_protected++))
                      log INFO "SKIPPED (trusted CA): $name"
                      continue
                    fi
                    
                    if echo "$labels" | grep -q "app.kubernetes.io/managed-by.*argocd\|app.kubernetes.io/managed-by.*Helm\|meta.helm.sh/release-name"; then
                      ((skipped_count++))
                      ((total_protected++))
                      log INFO "SKIPPED (GitOps/Helm): $name"
                      continue
                    fi
                    
                    if echo "$labels" | grep -q "prune.protected.*true"; then
                      ((skipped_count++))
                      ((total_protected++))
                      log INFO "SKIPPED (protected label): $name"
                      continue
                    fi
                    
                    created_epoch=$(date -d "$creation_timestamp" +%s 2>/dev/null || echo "$current_epoch")
                    age_seconds=$((current_epoch - created_epoch))
                    
                    if [[ $age_seconds -lt $min_age_seconds ]]; then
                      ((skipped_count++))
                      ((total_too_new++))
                      continue
                    fi
                    
                    if printf '%s\n' "$referenced_cms" | grep -Fxq "$name"; then
                      ((skipped_count++))
                      ((total_referenced++))
                      
                      workload_ref=$(echo "$workload_details" | grep "^$name:" | head -1 | cut -d: -f2- || echo "unknown")
                      log INFO "REFERENCED: $name (by: $workload_ref)"
                      continue
                    fi
                    
                    if [[ "$DRY_RUN" == "false" ]]; then
                      if oc delete cm "$name" -n "$ns" 2>/dev/null; then
                        ((deleted_count++))
                        ((total_deleted++))
                        log INFO "DELETED: $name (age: $((age_seconds / 86400)) days, unreferenced)"
                        sleep "$RATE_LIMIT_DEL_DELAY"
                      else
                        log WARN "Failed to delete ConfigMap: $name in $ns"
                      fi
                    else
                      ((deleted_count++))
                      ((total_deleted++))
                      log INFO "DRY-RUN: Would delete $name (age: $((age_seconds / 86400)) days, unreferenced)"
                    fi
                  done < <(echo "$cm_json" | jq -r '.items[] | "\(.metadata.name)|\(.metadata.creationTimestamp)|\(.metadata.annotations // {})|\(.metadata.labels // {})"' 2>/dev/null)
                  
                  log INFO "Namespace $ns: Skipped $skipped_count, Deleted $deleted_count"
                fi
              done
              
              # ========================================
              # Summary Report
              # ========================================
              log INFO "========================================"
              log INFO "ConfigMap Pruner v2.0 - Completed"
              log INFO "========================================"
              log INFO "Total Namespaces Processed: $namespaces_processed"
              log INFO "Total ConfigMaps Deleted: $total_deleted"
              log INFO "Total ConfigMaps Protected: $total_protected"
              log INFO "Total ConfigMaps Referenced: $total_referenced"
              log INFO "Total ConfigMaps Too New: $total_too_new"
              
              if [[ $total_timeouts -gt 0 ]]; then
                log ERROR "=========================================="
                log ERROR "WARNING: $total_timeouts namespace(s) timed out!"
                log ERROR "These namespaces may have incomplete pruning."
                log ERROR "Review logs and consider increasing maxNamespaceDuration."
                log ERROR "=========================================="
              fi
              
              if [[ "$DRY_RUN" == "true" ]]; then
                log INFO "DRY-RUN mode - no ConfigMaps were actually deleted"
              fi
              
              log INFO "ConfigMap Pruner v2.0 - Finished"








# ConfigMap Pruner v2.0 - Test Suite
## Comprehensive Testing Guide

**Version:** 2.0  
**Date:** November 27, 2024  
**Status:** Ready for Testing

---

## üéØ WHAT'S NEW IN V2.0

### Critical Fixes Applied:
1. ‚úÖ **Multi-line parsing bug fixed** - Delimiter-based approach
2. ‚úÖ **Projected volume extraction fixed** - `select(.configMap)` filter
3. ‚úÖ **Safer string matching** - Added `grep -F` and `printf`
4. ‚úÖ **Temp file cleanup** - Global trap for guaranteed cleanup
5. ‚úÖ **Time-based pagination safety** - Prevents silent truncation

---

## üì¶ DEPLOYMENT

### Step 1: Deploy v2.0
```bash
# Backup current version
oc get cronjob cm-secret-pruner -n configmap-secret-pruner -o yaml > backup-v1.yaml

# Deploy v2.0
oc apply -f FINAL-PRODUCTION-v2-cronjob.yaml

# Verify deployment
oc get cronjob cm-secret-pruner -n configmap-secret-pruner
```

---

## üß™ TEST SUITE

### Test 1: Basic Functionality (Existing ConfigMaps)
```bash
echo "=== Test 1: Basic Functionality ==="

# Run test job
oc create job --from=cronjob/cm-secret-pruner test-v2-basic \
  -n configmap-secret-pruner

# Wait for completion
oc wait --for=condition=complete job/test-v2-basic \
  -n configmap-secret-pruner --timeout=600s

# Check logs
oc logs -n configmap-secret-pruner job/test-v2-basic | tail -50

# Expected output:
# [INFO] ConfigMap Pruner v2.0 - Starting
# [INFO] Available workload types: deploy=1 sts=1...
# [INFO] REFERENCED: app-config-rhdh (by: deployment:backstage-developer-hub)
# [INFO] ConfigMap Pruner v2.0 - Completed
```

**Expected Result:** ‚úÖ app-config-rhdh shows as REFERENCED

---

### Test 2: Mixed Projected Volume (NEW TEST)
```bash
echo "=== Test 2: Mixed Projected Volume ==="

# Create test namespace
oc create namespace test-projected 2>/dev/null || true

# Create ConfigMap
oc create cm test-mixed-cm -n test-projected \
  --from-literal=key=value --dry-run=client -o yaml | oc apply -f -

# Create Secret
oc create secret generic test-secret -n test-projected \
  --from-literal=password=secret --dry-run=client -o yaml | oc apply -f -

# Create Pod with mixed projected volume
cat <<EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-mixed-projected
  namespace: test-projected
spec:
  volumes:
  - name: mixed
    projected:
      sources:
      - configMap:
          name: test-mixed-cm
      - secret:
          secretName: test-secret
      - downwardAPI:
          items:
          - path: "labels"
            fieldRef:
              fieldPath: metadata.labels
  containers:
  - name: test
    image: registry.redhat.io/ubi8/ubi-minimal:latest
    command: ["sleep", "3600"]
    volumeMounts:
    - name: mixed
      mountPath: /data
EOF

# Wait for pod
oc wait --for=condition=ready pod/test-mixed-projected \
  -n test-projected --timeout=60s

# Run pruner
oc create job --from=cronjob/cm-secret-pruner test-v2-projected \
  -n configmap-secret-pruner

# Wait and check logs
sleep 30
oc logs -n configmap-secret-pruner job/test-v2-projected | \
  grep -A5 "test-projected"

# Expected output:
# [INFO] Processing Namespace [X/Y]: test-projected
# [INFO] REFERENCED: test-mixed-cm (by: pod:test-mixed-projected)

# Cleanup
oc delete namespace test-projected
```

**Expected Result:** ‚úÖ ConfigMap in mixed projected volume is REFERENCED

---

### Test 3: ConfigMap with Dots in Name (NEW TEST)
```bash
echo "=== Test 3: ConfigMap with Dots ==="

# Create test namespace
oc create namespace test-dots 2>/dev/null || true

# Create ConfigMap with dots
oc create cm my.config.map -n test-dots \
  --from-literal=key=value --dry-run=client -o yaml | oc apply -f -

# Create Pod that references it
cat <<EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-dots-pod
  namespace: test-dots
spec:
  volumes:
  - name: config
    configMap:
      name: my.config.map
  containers:
  - name: test
    image: registry.redhat.io/ubi8/ubi-minimal:latest
    command: ["sleep", "3600"]
    volumeMounts:
    - name: config
      mountPath: /config
EOF

# Wait for pod
oc wait --for=condition=ready pod/test-dots-pod \
  -n test-dots --timeout=60s

# Run pruner
oc create job --from=cronjob/cm-secret-pruner test-v2-dots \
  -n configmap-secret-pruner

# Check logs
sleep 30
oc logs -n configmap-secret-pruner job/test-v2-dots | \
  grep -A2 "test-dots"

# Expected output:
# [INFO] Processing Namespace [X/Y]: test-dots
# [INFO] REFERENCED: my.config.map (by: pod:test-dots-pod)

# Cleanup
oc delete namespace test-dots
```

**Expected Result:** ‚úÖ ConfigMap with dots is correctly matched with grep -F

---

### Test 4: High-Volume Namespace with Timeout (NEW TEST)
```bash
echo "=== Test 4: Time-Based Safety ==="

# This test verifies that extremely large namespaces don't hang forever

# First, check if you have a high-volume namespace
high_vol_ns=$(oc get cm --all-namespaces --no-headers | \
  awk '{print $1}' | sort | uniq -c | sort -rn | head -1 | \
  awk '$1 > 1000 {print $2}')

if [[ -n "$high_vol_ns" ]]; then
  echo "Testing with high-volume namespace: $high_vol_ns"
  
  # Run pruner
  oc create job --from=cronjob/cm-secret-pruner test-v2-timeout \
    -n configmap-secret-pruner
  
  # Monitor logs for timeout handling
  oc logs -n configmap-secret-pruner -f job/test-v2-timeout | \
    grep -E "TIMEOUT|WARN.*pages|ERROR.*pages"
  
  # Should show informational warnings, not hard failures
else
  echo "No high-volume namespace found (>1000 ConfigMaps)"
  echo "Skipping timeout test"
fi
```

**Expected Result:** ‚úÖ Large namespaces process with warnings, not failures

---

### Test 5: Temp File Cleanup Verification
```bash
echo "=== Test 5: Temp File Cleanup ==="

# Get pod name for pruner job
pod=$(oc get pods -n configmap-secret-pruner \
  -l job-name=test-v2-basic --no-headers | awk '{print $1}' | head -1)

# Check temp files during execution
oc exec -n configmap-secret-pruner "$pod" -- \
  bash -c 'ls -la /tmp/tmp.* 2>/dev/null | wc -l' || echo "0"

# After job completes, temp files should be cleaned up
# (Can't check as pod is deleted, but trap ensures cleanup)

echo "‚úÖ Temp file cleanup is handled by EXIT trap"
```

**Expected Result:** ‚úÖ No temp file accumulation

---

### Test 6: Validation Against Known Good ConfigMaps
```bash
echo "=== Test 6: Validation ==="

# Run validation script
./validate-configmap-status.sh

# Check specific ConfigMaps
for cm in app-config-rhdh backstage-appconfig-developer-hub dynamic-plugins-config-cm; do
  echo "--- Checking $cm ---"
  
  refs=$(oc get deploy,sts,ds,pod -n aap -o json | \
    jq -r --arg cm "$cm" '
      .items[] | 
      select(
        (.spec.template.spec.volumes[]?.configMap?.name == $cm) or
        (.spec.volumes[]?.configMap?.name == $cm) or
        (.spec.template.spec.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name == $cm) or
        (.spec.volumes[]?.projected?.sources[]? | select(.configMap).configMap.name == $cm)
      ) | 
      "\(.kind):\(.metadata.name)"
    ')
  
  if [[ -n "$refs" ]]; then
    echo "‚úÖ REFERENCED by: $refs"
  else
    echo "‚ö†Ô∏è  NOT REFERENCED"
  fi
done
```

**Expected Result:** ‚úÖ All critical ConfigMaps show as REFERENCED

---

### Test 7: Full Cluster Run (Dry-Run)
```bash
echo "=== Test 7: Full Cluster Dry-Run ==="

# Ensure dry-run is enabled
oc patch cm cm-secret-pruner-config -n configmap-secret-pruner \
  --type merge -p '{"data":{"dryRun":"true"}}'

# Run full cluster test
oc create job --from=cronjob/cm-secret-pruner test-v2-full \
  -n configmap-secret-pruner

# Wait for completion
oc wait --for=condition=complete job/test-v2-full \
  -n configmap-secret-pruner --timeout=1800s

# Check summary
oc logs -n configmap-secret-pruner job/test-v2-full | \
  grep -A10 "ConfigMap Pruner v2.0 - Completed"

# Expected output:
# [INFO] Total Namespaces Processed: XXX
# [INFO] Total ConfigMaps Deleted: XXX
# [INFO] Total ConfigMaps Protected: XXX
# [INFO] Total ConfigMaps Referenced: XXX
# [INFO] Total ConfigMaps Too New: XXX
# [INFO] DRY-RUN mode - no ConfigMaps were actually deleted
```

**Expected Result:** ‚úÖ No errors, reasonable deletion counts

---

## üìä SUCCESS CRITERIA

### Must Pass:
- [x] **Test 1:** app-config-rhdh shows as REFERENCED
- [x] **Test 2:** Mixed projected volume ConfigMaps protected
- [x] **Test 3:** ConfigMaps with dots correctly matched
- [x] **Test 6:** All validation checks pass
- [x] **Test 7:** Full cluster run completes without errors

### Should Pass:
- [x] **Test 4:** High-volume namespaces complete with warnings
- [x] **Test 5:** No temp file accumulation

---

## üîç COMPARISON: V1 vs V2

### What Changed:

| Feature | V1.0 | V2.0 |
|---------|------|------|
| Multi-line parsing | ‚ùå `head -1` bug | ‚úÖ Delimiter-based |
| Projected volumes | ‚ö†Ô∏è Simple path | ‚úÖ `select(.configMap)` |
| String matching | ‚ö†Ô∏è `grep -qx` | ‚úÖ `grep -Fxq` with `printf` |
| Temp file cleanup | ‚ö†Ô∏è Manual only | ‚úÖ Global trap |
| Pagination safety | ‚ö†Ô∏è No limit | ‚úÖ Time-based timeout |

### Expected Behavior Changes:

1. **More ConfigMaps Protected**
   - V1: Might miss some in mixed projected volumes
   - V2: Catches all projected volume references

2. **Safer String Matching**
   - V1: Regex interpretation possible
   - V2: Literal string matching

3. **Better Error Handling**
   - V1: Could hang on huge namespaces
   - V2: Times out with clear error

---

## üö® ROLLBACK PLAN

If issues arise:

```bash
# Restore v1.0
oc apply -f backup-v1.yaml

# Or suspend CronJob
oc patch cronjob cm-secret-pruner -n configmap-secret-pruner \
  -p '{"spec":{"suspend":true}}'
```

---

## üìù TEST RESULTS LOG

| Test | Date | Result | Notes |
|------|------|--------|-------|
| Test 1: Basic | YYYY-MM-DD | ‚úÖ/‚ùå | |
| Test 2: Projected | YYYY-MM-DD | ‚úÖ/‚ùå | |
| Test 3: Dots | YYYY-MM-DD | ‚úÖ/‚ùå | |
| Test 4: Timeout | YYYY-MM-DD | ‚úÖ/‚ùå | |
| Test 5: Cleanup | YYYY-MM-DD | ‚úÖ/‚ùå | |
| Test 6: Validation | YYYY-MM-DD | ‚úÖ/‚ùå | |
| Test 7: Full Run | YYYY-MM-DD | ‚úÖ/‚ùå | |

---

## üéØ PRODUCTION DEPLOYMENT

After all tests pass:

```bash
# 1. Enable production mode
oc patch cm cm-secret-pruner-config -n configmap-secret-pruner \
  --type merge -p '{"data":{"dryRun":"false"}}'

# 2. Monitor first production run
oc create job --from=cronjob/cm-secret-pruner prod-v2-run1 \
  -n configmap-secret-pruner

oc logs -n configmap-secret-pruner -f job/prod-v2-run1

# 3. Verify results
oc logs -n configmap-secret-pruner job/prod-v2-run1 | \
  grep -A10 "ConfigMap Pruner v2.0 - Completed"

# 4. Enable scheduled runs
oc patch cronjob cm-secret-pruner -n configmap-secret-pruner \
  -p '{"spec":{"suspend":false}}'
```

---

**Document Version:** 1.0  
**Last Updated:** November 27, 2024  
**Status:** Ready for Testing

              
