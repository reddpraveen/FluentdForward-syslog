#!/bin/bash
set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
RESULTS_DIR="$HOME/etcd_benchmark_$(date +%Y%m%d_%H%M%S)"
FIO_SIZE="1G"
FIO_RUNTIME=60
FIO_JOBS=4
FIO_TIMEOUT=300  # 5 minutes timeout per test

# Create results directory
mkdir -p "$RESULTS_DIR"
log_file="$RESULTS_DIR/etcd_benchmark.log"

# Logging functions
log() {
  local level=$1
  shift
  local color
  local level_upper
  level_upper=$(echo "$level" | tr '[:lower:]' '[:upper:]')
  
  case "$level" in
    info) color="$GREEN" ;;
    warn) color="$YELLOW" ;;
    error) color="$RED" ;;
    *) color="$NC" ;;
  esac

  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local message="[$timestamp] $level_upper: $*"
  
  echo -e "${color}${message}${NC}" | tee -a "$log_file"
}

log_info() {
  log info "$@"
}

log_warn() {
  log warn "$@"
}

log_error() {
  log error "$@"
  exit 1
}

log_section() {
  echo -e "\n${BLUE}===== $* =====${NC}" | tee -a "$log_file"
}

# Check prerequisites
check_prerequisites() {
  log_section "Checking Prerequisites"
  
  # Check oc is installed and logged in
  if ! command -v oc &> /dev/null; then
    log_error "OpenShift CLI (oc) is not installed or not in PATH"
  fi
  
  # Check cluster connection
  if ! oc whoami &> /dev/null; then
    log_error "Not logged into OpenShift cluster. Please run 'oc login' first."
  fi
  
  # Check if user has cluster-admin privileges
  if ! oc auth can-i '*' '*' --all-namespaces &> /dev/null; then
    log_warn "User does not have cluster-admin privileges. Some checks may fail."
  fi

  # Check if jq is installed
  if ! command -v jq &> /dev/null; then
    log_warn "jq is not installed. Some features may be limited."
  fi

  # Check if timeout is available
  if ! command -v timeout &> /dev/null; then
    log_warn "timeout command not found. Timeout functionality may not work as expected."
  fi
  
  log_info "All prerequisites met"
}

# Run FIO test on node with timeout and better error handling
run_fio_test() {
  local node=$1
  local test_name=$2
  local fio_params=$3
  
  local result_file="$RESULTS_DIR/fio_${node//\//_}_${test_name}.json"
  local log_file="$RESULTS_DIR/fio_${node//\//_}_${test_name}.log"
  
  log_info "Starting FIO test '$test_name' on $node (timeout: ${FIO_TIMEOUT}s)"
  
  # Create a cleanup function
  cleanup() {
    local pid=$1
    log_warn "Test '$test_name' on $node timed out after ${FIO_TIMEOUT}s"
    kill -TERM "$pid" 2>/dev/null || true
    return 1
  }
  
  # Run FIO in background with timeout
  (
    echo "=== FIO Test: $test_name ==="
    echo "Node: $node"
    echo "Command: fio --output-format=json $fio_params"
    echo "Timestamp: $(date)"
    echo "Timeout: ${FIO_TIMEOUT} seconds"
    echo "==========================="
    echo
    
    oc debug "node/$node" --quiet -- chroot /host bash -c "
      # Set error handling
      set -euo pipefail
      
      # Install fio if not present
      if ! command -v fio &> /dev/null; then
        echo 'Installing fio...'
        if command -v dnf &> /dev/null; then
          dnf install -y fio || yum install -y fio || {
            echo 'ERROR: Failed to install fio' >&2
            exit 1
          }
        else
          echo 'ERROR: Could not find package manager to install fio' >&2
          exit 1
        fi
      fi
      
      # Create test directory
      test_dir=\"/var/tmp/fio_test_$(date +%s)\"
      mkdir -p \"\$test_dir\"
      trap 'rm -rf \"\$test_dir\"' EXIT
      
      # Create test file
      test_file=\"\$test_dir/fio_test\"
      echo \"Creating test file: \$test_file\"
      if ! fallocate -l 2G \"\$test_file\" 2>/dev/null; then
        # Fallback to dd if fallocate fails
        echo \"fallocate failed, trying dd...\"
        if ! dd if=/dev/zero of=\"\$test_file\" bs=1M count=2048 status=none; then
          echo 'ERROR: Failed to create test file' >&2
          exit 1
        fi
      fi
      
      # Run fio with timeout
      echo \"Starting FIO test...\"
      timeout ${FIO_TIMEOUT} fio --filename=\$test_file --output-format=json $fio_params || {
        if [ \$? -eq 124 ]; then
          echo \"ERROR: FIO test timed out after ${FIO_TIMEOUT} seconds\" >&2
        else
          echo \"ERROR: FIO test failed with exit code \$?\" >&2
        fi
        exit 1
      }
    " 2>&1
  ) > "$result_file" 2> >(tee -a "$log_file" >&2) &
  
  local pid=$!
  
  # Set timeout for the entire test
  ( sleep "$FIO_TIMEOUT" && cleanup "$pid" ) 2>/dev/null &
  local timeout_pid=$!
  
  # Wait for the test to complete
  if wait "$pid" 2>/dev/null; then
    # Test completed successfully
    kill "$timeout_pid" 2>/dev/null || true
    
    # Verify the output is valid JSON
    if ! jq empty "$result_file" 2>/dev/null; then
      log_warn "Invalid JSON output from FIO test. Check $log_file for details."
      return 1
    fi
    
    # Parse and log summary
    local iops lat
    iops=$(jq -r '.jobs[0].write.iops // 0' "$result_file" 2>/dev/null)
    lat=$(jq -r '.jobs[0].write.lat_ns.mean // 0' "$result_file" 2>/dev/null)
    lat=$(awk "BEGIN {printf \"%.2f\", $lat/1000000}") # Convert ns to ms
    
    log_info "Test '$test_name' completed on $node - IOPS: $iops, Latency: ${lat}ms"
    return 0
  else
    # Test failed or timed out
    log_error "FIO test '$test_name' failed on $node. Check $log_file for details."
    return 1
  fi
}

# Collect etcd metrics
collect_etcd_metrics() {
  log_section "Collecting etcd Metrics"
  local metrics_file="$RESULTS_DIR/etcd_metrics.json"
  if oc get --raw /metrics > "$metrics_file" 2>/dev/null; then
    log_info "Collected etcd metrics to $metrics_file"
  else
    log_warn "Failed to collect etcd metrics"
  fi
}

# Collect etcd status
collect_etcd_status() {
  log_section "Collecting etcd Status"
  local status_file="$RESULTS_DIR/etcd_status.log"
  
  {
    echo "=== etcdctl member list ==="
    oc rsh -n openshift-etcd "$(oc get pods -n openshift-etcd -l app=etcd -o name | head -1)" etcdctl member list -w table 2>&1 || true
    
    echo -e "\n=== etcdctl endpoint status ==="
    oc rsh -n openshift-etcd "$(oc get pods -n openshift-etcd -l app=etcd -o name | head -1)" etcdctl endpoint status -w table --cluster 2>&1 || true
    
    echo -e "\n=== etcdctl endpoint health ==="
    oc rsh -n openshift-etcd "$(oc get pods -n openshift-etcd -l app=etcd -o name | head -1)" etcdctl endpoint health --cluster 2>&1 || true
  } > "$status_file"
  
  log_info "etcd status saved to $status_file"
}

# Generate summary report
generate_summary() {
  log_section "Generating Summary Report"
  local summary_file="$RESULTS_DIR/summary.txt"
  local start_time=$1
  local end_time
  end_time=$(date +%s)
  local duration=$((end_time - start_time))
  
  {
    echo "=== etcd Performance Benchmark Summary ==="
    echo "Date: $(date)"
    echo "OpenShift Version: $(oc version -o json 2>/dev/null | jq -r .serverVersion.gitVersion || echo "Unknown")"
    echo "Test Duration: $((duration / 60)) minutes $((duration % 60)) seconds"
    echo "Results Directory: $RESULTS_DIR"
    echo "========================================"
    echo
    
    # FIO results summary
    echo "=== Disk Performance ==="
    find "$RESULTS_DIR" -name "fio_*.json" 2>/dev/null | while read -r f; do
      local node_test
      node_test=$(basename "$f" .json | sed 's/fio_//')
      local iops
      iops=$(jq -r '.jobs[0].write.iops // 0' "$f" 2>/dev/null || echo "0")
      local lat
      lat=$(jq -r '.jobs[0].write.lat_ns.mean // 0' "$f" 2>/dev/null || echo "0")
      lat=$(awk "BEGIN {printf \"%.2f\", $lat/1000000}" 2>/dev/null || echo "0.00")
      
      printf "%-40s: IOPS=%8.2f, Latency=%6.2fms\n" "$node_test" "$iops" "$lat"
    done
    
    # etcd status summary
    echo -e "\n=== etcd Cluster Status ==="
    local status_file="$RESULTS_DIR/etcd_status.log"
    if [ -f "$status_file" ]; then
      grep -A 10 "etcdctl member list" "$status_file" 2>/dev/null | tail -n +2 || 
        echo "No etcd member list found in status file"
    else
      echo "Status file not found: $status_file"
    fi
  } > "$summary_file"
  
  log_info "Benchmark completed successfully!"
  log_info "Summary report: $summary_file"
  log_info "Detailed logs: $log_file"
}

# Main function
main() {
  local start_time
  start_time=$(date +%s)
  
  log_section "Starting etcd Performance Benchmark"
  log_info "Results will be saved to: $RESULTS_DIR"
  
  check_prerequisites
  
  # Get etcd nodes
  log_section "Discovering etcd Nodes"
  local etcd_nodes
  etcd_nodes=$(oc get nodes -l node-role.kubernetes.io/master= -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')
  
  if [ -z "$etcd_nodes" ]; then
    log_error "No etcd nodes found"
  fi
  
  log_info "Found etcd nodes:"
  echo "$etcd_nodes" | while read -r node; do
    log_info "- $node"
  done
  
  # Run FIO tests on each etcd node
  log_section "Running Disk Performance Tests"
  for node in $etcd_nodes; do
    log_info "Testing node: $node"
    
    # Sequential write test
    run_fio_test "$node" "seq_write" "\
      --name=seq_write \
      --size=$FIO_SIZE \
      --runtime=$FIO_RUNTIME \
      --ioengine=sync \
      --rw=write \
      --bs=4k \
      --numjobs=1 \
      --time_based \
      --direct=1 \
      --group_reporting"
    
    # Random write test
    run_fio_test "$node" "rand_write" "\
      --name=rand_write \
      --size=$FIO_SIZE \
      --runtime=$FIO_RUNTIME \
      --ioengine=libaio \
      --rw=randwrite \
      --bs=4k \
      --numjobs=$FIO_JOBS \
      --time_based \
      --direct=1 \
      --group_reporting"
    
    # Fsync test
    run_fio_test "$node" "fsync" "\
      --name=fsync \
      --size=1G \
      --filesize=1G \
      --ioengine=sync \
      --rw=write \
      --bs=4k \
      --numjobs=1 \
      --fsync=1 \
      --time_based \
      --runtime=30 \
      --direct=1 \
      --group_reporting"
  done
  
  # Collect additional diagnostics
  collect_etcd_metrics
  collect_etcd_status
  
  # Generate final report
  generate_summary "$start_time"
}

# Run main function
main "$@"
