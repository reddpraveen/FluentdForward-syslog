apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-secret-pruner-config
  namespace: configmap-secret-pruner
data:
  # DRY-RUN MODE - Set to "false" to enable actual deletions
  dryRun: "true"
  
  # Minimum age in days before a ConfigMap can be deleted
  minAgeDays: "7"
  
  # High-volume threshold (namespaces with MORE than this are "high-volume")
  highVolumeThreshold: "1000"
  
  # Enable pagination processing for high-volume namespaces
  # false = skip high-volume namespaces (report them)
  # true  = process high-volume namespaces via pagination
  processHighVolumeNamespaces: "false"
  
  # Process ONLY high-volume namespaces (optimization for Pass 2)
  # false = process all namespaces (normal mode)
  # true  = skip normal namespaces, only process high-volume ones
  # IMPORTANT: Must set processHighVolumeNamespaces=true when using this!
  processOnlyHighVolume: "false"
  
  # Pagination chunk size (ConfigMaps per page)
  paginationLimit: "500"
  
  # Namespace patterns to exclude (regex)
  excludedNamespaces: |
    ^openshift-.*
    ^kube-.*
    ^default$
    ^openshift$
    ^configmap-secret-pruner$
  
  # Label-based protection rules
  protectedLabels: |
    app.kubernetes.io/managed-by=argocd
    app.kubernetes.io/managed-by=Helm
    meta.helm.sh/release-name
    prune.protected=true
  
  # System ConfigMap names to exclude (auto-injected)
  excludedConfigMapNames: |
    openshift-service-ca.crt
    kube-root-ca.crt
    istio-ca-root-cert
    openshift-ca.crt



apiVersion: batch/v1
kind: CronJob
metadata:
  name: cm-secret-pruner
  namespace: configmap-secret-pruner
  labels:
    app.kubernetes.io/name: cm-secret-pruner
    app.kubernetes.io/component: cleanup
spec:
  schedule: "0 2 * * 0"
  timeZone: America/New_York
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 2
      activeDeadlineSeconds: 7200
      ttlSecondsAfterFinished: 86400
      template:
        spec:
          serviceAccountName: cm-secret-pruner
          restartPolicy: Never
          tolerations:
          - key: "node-role.kubernetes.io/infra"
            operator: "Exists"
            effect: "NoSchedule"
          containers:
          - name: pruner
            image: registry.redhat.io/openshift4/ose-cli:v4.16
            resources:
              requests:
                memory: "128Mi"
                cpu: "10m"
              limits:
                memory: "256Mi"
                cpu: "100m"
            env:
            - name: DELAY_BETWEEN_NAMESPACES
              value: "0.1"
            - name: DELAY_BETWEEN_DELETIONS
              value: "0.05"
            - name: BATCH_SIZE
              value: "10"
            - name: BATCH_PAUSE
              value: "0.5"
            command:
            - /bin/bash
            - -c
            - |
              set -uo pipefail
              
              DELAY_NS="${DELAY_BETWEEN_NAMESPACES:-0.5}"
              DELAY_DEL="${DELAY_BETWEEN_DELETIONS:-0.1}"
              BATCH_SIZE="${BATCH_SIZE:-10}"
              BATCH_PAUSE="${BATCH_PAUSE:-1}"
              
              total_deleted=0
              total_skipped=0
              total_protected=0
              total_too_new=0
              total_referenced=0
              total_system_cm=0
              total_errors=0
              namespaces_processed=0
              namespaces_excluded=0
              namespaces_high_volume=0
              namespaces_paginated=0
              namespaces_skipped_by_mode=0
              deletion_batch_count=0
              
              declare -a high_volume_ns_list
              
              log() {
                local level="$1"
                shift
                printf '%s [%s] %s\n' "$(TZ='America/New_York' date '+%Y-%m-%d %H:%M:%S %Z')" "$level" "$*" >&2
              }
              
              error_exit() {
                log ERROR "$1"
                exit 1
              }
              
              log INFO "========================================="
              log INFO "ConfigMap Pruner - Production Mode"
              log INFO "========================================="
              log INFO "Rate Limiting Settings:"
              log INFO "  Delay between namespaces: ${DELAY_NS}s"
              log INFO "  Delay between deletions: ${DELAY_DEL}s"
              log INFO "  Batch size: $BATCH_SIZE"
              log INFO "  Batch pause: ${BATCH_PAUSE}s"
              log INFO "========================================="
              
              NS="configmap-secret-pruner"
              CM="cm-secret-pruner-config"
              
              log INFO "Verifying cluster access..."
              if ! oc whoami &>/dev/null; then
                error_exit "Unable to authenticate"
              fi
              log INFO "Authenticated as: $(oc whoami)"
              
              if ! oc -n "$NS" get cm "$CM" &>/dev/null; then
                error_exit "ConfigMap $CM not found in namespace $NS"
              fi
              log INFO "ConfigMap found: $CM"
              
              # Load configuration
              DRY_RUN=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.dryRun}' 2>/dev/null || echo "true")
              [[ -z "$DRY_RUN" ]] && DRY_RUN="true"
              
              MIN_AGE_DAYS=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.minAgeDays}' 2>/dev/null || echo "7")
              [[ -z "$MIN_AGE_DAYS" ]] && MIN_AGE_DAYS="7"
              
              HIGH_VOLUME_THRESHOLD=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.highVolumeThreshold}' 2>/dev/null || echo "1000")
              [[ -z "$HIGH_VOLUME_THRESHOLD" ]] && HIGH_VOLUME_THRESHOLD="1000"
              
              PROCESS_HIGH_VOLUME=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.processHighVolumeNamespaces}' 2>/dev/null || echo "false")
              [[ -z "$PROCESS_HIGH_VOLUME" ]] && PROCESS_HIGH_VOLUME="false"
              
              PAGINATION_LIMIT=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.paginationLimit}' 2>/dev/null || echo "500")
              [[ -z "$PAGINATION_LIMIT" ]] && PAGINATION_LIMIT="500"
              
              # NEW: High-volume only mode
              PROCESS_ONLY_HIGH_VOLUME=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.processOnlyHighVolume}' 2>/dev/null || echo "false")
              [[ -z "$PROCESS_ONLY_HIGH_VOLUME" ]] && PROCESS_ONLY_HIGH_VOLUME="false"
              
              EXCLUDED_NS=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.excludedNamespaces}' 2>/dev/null || echo "")
              if [[ -z "$EXCLUDED_NS" ]]; then
                EXCLUDED_NS=$(printf '%s\n' '^openshift-.*' '^kube-.*' '^default$' '^openshift$' '^configmap-secret-pruner$')
              fi
              
              PROTECTED_LABELS=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.protectedLabels}' 2>/dev/null || echo "")
              if [[ -z "$PROTECTED_LABELS" ]]; then
                PROTECTED_LABELS=$(printf '%s\n' 'app.kubernetes.io/managed-by=argocd' 'app.kubernetes.io/managed-by=Helm' 'meta.helm.sh/release-name' 'prune.protected=true')
              fi
              
              EXCLUDED_CM_NAMES=$(oc -n "$NS" get cm "$CM" -o jsonpath='{.data.excludedConfigMapNames}' 2>/dev/null || echo "")
              if [[ -z "$EXCLUDED_CM_NAMES" ]]; then
                EXCLUDED_CM_NAMES=$(printf '%s\n' \
                  'openshift-service-ca.crt' \
                  'kube-root-ca.crt' \
                  'istio-ca-root-cert' \
                  'openshift-ca.crt')
              fi
              
              EXCLUDED_NS=$(echo "$EXCLUDED_NS" | sed '/^[[:space:]]*$/d')
              PROTECTED_LABELS=$(echo "$PROTECTED_LABELS" | sed '/^[[:space:]]*$/d')
              EXCLUDED_CM_NAMES=$(echo "$EXCLUDED_CM_NAMES" | sed '/^[[:space:]]*$/d')
              
              log INFO "Configuration loaded:"
              log INFO "  DRY_RUN: $DRY_RUN"
              log INFO "  MIN_AGE_DAYS: $MIN_AGE_DAYS"
              log INFO "  HIGH_VOLUME_THRESHOLD: $HIGH_VOLUME_THRESHOLD ConfigMaps"
              log INFO "  PROCESS_HIGH_VOLUME: $PROCESS_HIGH_VOLUME"
              log INFO "  PROCESS_ONLY_HIGH_VOLUME: $PROCESS_ONLY_HIGH_VOLUME"
              
              if [[ "$PROCESS_ONLY_HIGH_VOLUME" == "true" ]]; then
                log INFO "  MODE: High-Volume Only (skipping normal namespaces)"
                if [[ "$PROCESS_HIGH_VOLUME" == "false" ]]; then
                  log WARN "  WARNING: processOnlyHighVolume=true but processHighVolumeNamespaces=false"
                  log WARN "  This will result in all namespaces being skipped!"
                fi
              else
                log INFO "  MODE: Normal (processing all namespaces)"
              fi
              
              if [[ "$PROCESS_HIGH_VOLUME" == "true" ]]; then
                log INFO "  PAGINATION_LIMIT: $PAGINATION_LIMIT ConfigMaps per page"
              fi
              
              log INFO "Excluded namespace patterns:"
              while IFS= read -r pattern; do
                [[ -n "$pattern" ]] && log INFO "  - $pattern"
              done <<< "$EXCLUDED_NS"
              
              log INFO "Protected labels:"
              while IFS= read -r label; do
                [[ -n "$label" ]] && log INFO "  - $label"
              done <<< "$PROTECTED_LABELS"
              
              log INFO "Excluded ConfigMap names (system-injected):"
              while IFS= read -r cm_name; do
                [[ -n "$cm_name" ]] && log INFO "  - $cm_name"
              done <<< "$EXCLUDED_CM_NAMES"
              
              # Process ConfigMaps function
              process_configmaps() {
                local ns="$1"
                local cm_json="$2"
                local referenced_cms="$3"
                local deleted_count=0
                local skipped_count=0
                local batch_counter=0
                
                while IFS= read -r cm_data; do
                  [[ -z "$cm_data" ]] && continue
                  
                  name=$(echo "$cm_data" | jq -r '.name' 2>/dev/null)
                  [[ -z "$name" || "$name" == "null" ]] && continue
                  
                  annotations=$(echo "$cm_data" | jq -r '.annotations // {}' 2>/dev/null)
                  
                  inject_cabundle=$(echo "$annotations" | jq -r '."service.beta.openshift.io/inject-cabundle" // ."service.alpha.openshift.io/inject-cabundle" // empty' 2>/dev/null)
                  if [[ "$inject_cabundle" == "true" ]]; then
                    ((skipped_count++))
                    ((total_system_cm++))
                    continue
                  fi
                  
                  excluded_by_name=false
                  while IFS= read -r excluded_name; do
                    [[ -z "$excluded_name" ]] && continue
                    if [[ "$name" == "$excluded_name" ]]; then
                      excluded_by_name=true
                      ((skipped_count++))
                      ((total_system_cm++))
                      break
                    fi
                  done <<< "$EXCLUDED_CM_NAMES"
                  [[ "$excluded_by_name" == "true" ]] && continue
                  
                  labels=$(echo "$cm_data" | jq -r '.labels // {}' 2>/dev/null)
                  
                  inject_trusted_ca=$(echo "$labels" | jq -r '."config.openshift.io/inject-trusted-cabundle" // empty' 2>/dev/null)
                  if [[ "$inject_trusted_ca" == "true" ]]; then
                    ((skipped_count++))
                    ((total_system_cm++))
                    continue
                  fi
                  
                  created=$(echo "$cm_data" | jq -r '.created' 2>/dev/null)
                  
                  skip=false
                  while IFS= read -r label_rule; do
                    [[ -z "$label_rule" ]] && continue
                    
                    if [[ "$label_rule" == *"="* ]]; then
                      key="${label_rule%=*}"
                      expected="${label_rule#*=}"
                      actual=$(echo "$labels" | jq -r ".\\"$key\\" // empty" 2>/dev/null)
                      if [[ "$actual" == "$expected" ]]; then
                        skip=true
                        ((total_protected++))
                        break
                      fi
                    else
                      if echo "$labels" | jq -e ".\\"$label_rule\\"" &>/dev/null; then
                        skip=true
                        ((total_protected++))
                        break
                      fi
                    fi
                  done <<< "$PROTECTED_LABELS"
                  
                  if [[ "$skip" == "true" ]]; then
                    ((skipped_count++))
                    continue
                  fi
                  
                  age_days="unknown"
                  if [[ -n "$created" && "$created" != "null" ]]; then
                    created_epoch=$(date -d "$created" +%s 2>/dev/null || echo "0")
                    if [[ "$created_epoch" -gt 0 ]]; then
                      age_seconds=$((current_epoch - created_epoch))
                      age_days=$((age_seconds / 86400))
                      
                      if [[ "$age_seconds" -lt "$min_age_seconds" ]]; then
                        ((skipped_count++))
                        ((total_too_new++))
                        continue
                      fi
                    fi
                  fi
                  
                  if echo "$referenced_cms" | grep -qx "$name" 2>/dev/null; then
                    ((skipped_count++))
                    ((total_referenced++))
                    continue
                  fi
                  
                  if [[ "$DRY_RUN" == "false" ]]; then
                    sleep "$DELAY_DEL"
                    
                    if oc delete cm "$name" -n "$ns" --wait=false &>/dev/null; then
                      ((deleted_count++))
                      ((total_deleted++))
                      ((batch_counter++))
                      
                      if [[ $((batch_counter % BATCH_SIZE)) -eq 0 ]]; then
                        sleep "$BATCH_PAUSE"
                      fi
                    else
                      ((total_errors++))
                    fi
                  else
                    ((deleted_count++))
                    ((total_deleted++))
                  fi
                  
                done < <(echo "$cm_json" | jq -c '.items[] | {name: .metadata.name, labels: .metadata.labels, annotations: .metadata.annotations, created: .metadata.creationTimestamp}' 2>/dev/null)
                
                echo "$deleted_count:$skipped_count"
              }
              
              # Process high-volume namespace with pagination
              process_high_volume_namespace() {
                local ns="$1"
                local total_cm_count="$2"
                
                log INFO "  HIGH-VOLUME: $ns has $total_cm_count ConfigMaps"
                log INFO "  PAGINATED: Processing in chunks of $PAGINATION_LIMIT ConfigMaps"
                
                ((namespaces_paginated++))
                
                log INFO "  Fetching workload references..."
                local referenced_cms=""
                referenced_cms=$(oc get deploy,sts,ds,cronjob,job,pod -n "$ns" -o json 2>/dev/null | jq -r '
                  [
                    .items[]? | 
                    (
                      (select(.kind == "Deployment" or .kind == "StatefulSet" or .kind == "DaemonSet") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                          (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "CronJob") |
                        .spec.jobTemplate.spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "Job") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "Pod") |
                        .spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                          (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      )
                    )
                  ] | unique | .[]
                ' 2>/dev/null || echo "")
                
                local deleted_in_ns=0
                local skipped_in_ns=0
                local continue_token=""
                local page_num=0
                local total_pages=$(( (total_cm_count + PAGINATION_LIMIT - 1) / PAGINATION_LIMIT ))
                
                log INFO "  Estimated pages: $total_pages"
                
                while true; do
                  ((page_num++))
                  log INFO "  Processing page $page_num/$total_pages..."
                  
                  local page_result=""
                  if [[ -z "$continue_token" ]]; then
                    page_result=$(oc get cm -n "$ns" --limit="$PAGINATION_LIMIT" -o json 2>/dev/null)
                  else
                    page_result=$(oc get cm -n "$ns" --limit="$PAGINATION_LIMIT" --continue="$continue_token" -o json 2>/dev/null)
                  fi
                  
                  if [[ -z "$page_result" ]]; then
                    log WARN "  Failed to fetch page $page_num"
                    break
                  fi
                  
                  local page_counts
                  page_counts=$(process_configmaps "$ns" "$page_result" "$referenced_cms")
                  local page_deleted="${page_counts%:*}"
                  local page_skipped="${page_counts#*:}"
                  
                  ((deleted_in_ns += page_deleted))
                  ((skipped_in_ns += page_skipped))
                  
                  log INFO "  Page $page_num: deleted=$page_deleted skipped=$page_skipped"
                  
                  continue_token=$(echo "$page_result" | jq -r '.metadata.continue // empty' 2>/dev/null)
                  
                  if [[ -z "$continue_token" ]]; then
                    log INFO "  Completed all pages"
                    break
                  fi
                  
                  sleep 0.5
                done
                
                log INFO "  Namespace total: deleted=$deleted_in_ns skipped=$skipped_in_ns"
                ((total_skipped += skipped_in_ns))
              }
              
              # Get all namespaces
              log INFO "Fetching namespace list..."
              namespace_list=$(oc get ns -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n' | sort)
              if [[ -z "$namespace_list" ]]; then
                error_exit "No namespaces found"
              fi
              namespace_count=$(echo "$namespace_list" | wc -l)
              log INFO "Found $namespace_count namespaces in cluster"
              
              current_epoch=$(date +%s)
              min_age_seconds=$((MIN_AGE_DAYS * 86400))
              
              start_time=$(date +%s)
              
              while IFS= read -r ns; do
                [[ -z "$ns" ]] && continue
                
                # Check exclusion
                excluded=false
                while IFS= read -r pattern; do
                  [[ -z "$pattern" ]] && continue
                  if echo "$ns" | grep -Eq "$pattern" 2>/dev/null; then
                    excluded=true
                    break
                  fi
                done <<< "$EXCLUDED_NS"
                
                if [[ "$excluded" == "true" ]]; then
                  ((namespaces_excluded++))
                  continue
                fi
                
                ((namespaces_processed++))
                
                if [[ $((namespaces_processed % 50)) -eq 0 ]]; then
                  elapsed=$(($(date +%s) - start_time))
                  log INFO "Progress: $namespaces_processed namespaces processed in ${elapsed}s"
                fi
                
                log INFO "Processing [$namespaces_processed]: $ns"
                
                # Quick count check
                cm_count=0
                if ! cm_count=$(oc get cm -n "$ns" --no-headers 2>/dev/null | wc -l); then
                  log WARN "  Unable to count ConfigMaps in: $ns"
                  ((total_errors++))
                  sleep "$DELAY_NS"
                  continue
                fi
                
                if [[ "$cm_count" -eq 0 ]]; then
                  log INFO "  No ConfigMaps found"
                  sleep "$DELAY_NS"
                  continue
                fi
                
                # High-volume only mode check
                if [[ "$PROCESS_ONLY_HIGH_VOLUME" == "true" ]]; then
                  if [[ "$cm_count" -le "$HIGH_VOLUME_THRESHOLD" ]]; then
                    log INFO "  SKIPPED (high-volume-only mode): $cm_count ConfigMaps (threshold: $HIGH_VOLUME_THRESHOLD)"
                    ((namespaces_skipped_by_mode++))
                    sleep 0.01
                    continue
                  fi
                fi
                
                # High-volume namespace handling
                if [[ "$cm_count" -gt "$HIGH_VOLUME_THRESHOLD" ]]; then
                  if [[ "$PROCESS_HIGH_VOLUME" == "true" ]]; then
                    process_high_volume_namespace "$ns" "$cm_count"
                  else
                    log WARN "  HIGH-VOLUME: $ns has $cm_count ConfigMaps (threshold: $HIGH_VOLUME_THRESHOLD)"
                    log WARN "  SKIPPED: Set processHighVolumeNamespaces=true to enable pagination"
                    high_volume_ns_list+=("$ns:$cm_count")
                    ((namespaces_high_volume++))
                  fi
                  sleep "$DELAY_NS"
                  continue
                fi
                
                # Regular processing
                log INFO "  Found $cm_count ConfigMap(s)"
                
                cm_json=""
                if ! cm_json=$(oc get cm -n "$ns" -o json 2>/dev/null); then
                  log WARN "  Unable to list ConfigMaps in: $ns"
                  ((total_errors++))
                  sleep "$DELAY_NS"
                  continue
                fi
                
                non_system_count=$(echo "$cm_json" | jq -r --arg excluded "$EXCLUDED_CM_NAMES" '
                  [.items[] | 
                   select(
                     ([.metadata.name] | inside([$excluded | split("\n")[] | select(length > 0)])) == false and
                     ((.metadata.annotations // {})["service.beta.openshift.io/inject-cabundle"] // "false") != "true" and
                     ((.metadata.annotations // {})["service.alpha.openshift.io/inject-cabundle"] // "false") != "true" and
                     ((.metadata.labels // {})["config.openshift.io/inject-trusted-cabundle"] // "false") != "true"
                   )
                  ] | length
                ' 2>/dev/null || echo "$cm_count")
                
                if [[ "$non_system_count" -eq 0 ]]; then
                  log INFO "  All system ConfigMaps, skipping"
                  ((total_system_cm += cm_count))
                  ((total_skipped += cm_count))
                  sleep "$DELAY_NS"
                  continue
                fi
                
                log INFO "  ($non_system_count non-system)"
                
                referenced_cms=""
                referenced_cms=$(oc get deploy,sts,ds,cronjob,job,pod -n "$ns" -o json 2>/dev/null | jq -r '
                  [
                    .items[]? | 
                    (
                      (select(.kind == "Deployment" or .kind == "StatefulSet" or .kind == "DaemonSet") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                          (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "CronJob") |
                        .spec.jobTemplate.spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "Job") |
                        .spec.template.spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      ),
                      (select(.kind == "Pod") |
                        .spec | (
                          (.volumes[]?.configMap?.name // empty),
                          (.containers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.containers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty),
                          (.initContainers[]?.envFrom[]?.configMapRef?.name // empty),
                          (.initContainers[]?.env[]?.valueFrom?.configMapKeyRef?.name // empty)
                        )
                      )
                    )
                  ] | unique | .[]
                ' 2>/dev/null || echo "")
                
                counts=$(process_configmaps "$ns" "$cm_json" "$referenced_cms")
                deleted_in_ns="${counts%:*}"
                skipped_in_ns="${counts#*:}"
                
                if [[ "$deleted_in_ns" -gt 0 || "$skipped_in_ns" -gt 0 ]]; then
                  log INFO "  Namespace summary: deleted=$deleted_in_ns skipped=$skipped_in_ns"
                fi
                ((total_skipped += skipped_in_ns))
                
                sleep "$DELAY_NS"
                
              done <<< "$namespace_list"
              
              end_time=$(date +%s)
              duration=$((end_time - start_time))
              duration_min=$((duration / 60))
              duration_sec=$((duration % 60))
              
              log INFO ""
              log INFO "========================================="
              log INFO "Job Completed Successfully"
              log INFO "========================================="
              log INFO "Duration: ${duration_min}m ${duration_sec}s"
              log INFO ""
              log INFO "Namespace Statistics:"
              log INFO "  Total in cluster: $namespace_count"
              log INFO "  Excluded by pattern: $namespaces_excluded"
              if [[ "$PROCESS_ONLY_HIGH_VOLUME" == "true" ]]; then
                log INFO "  Skipped (below threshold in high-volume-only mode): $namespaces_skipped_by_mode"
              fi
              log INFO "  High-volume (processed with pagination): $namespaces_paginated"
              log INFO "  High-volume (skipped): $namespaces_high_volume"
              log INFO "  Processed normally: $((namespaces_processed - namespaces_paginated - namespaces_skipped_by_mode))"
              log INFO ""
              
              if [[ "$namespaces_high_volume" -gt 0 ]]; then
                log WARN "========================================="
                log WARN "High-Volume Namespaces Skipped"
                log WARN "========================================="
                log WARN "The following namespaces exceed $HIGH_VOLUME_THRESHOLD ConfigMaps"
                log WARN "and were skipped. To process them, set:"
                log WARN "  processHighVolumeNamespaces: true"
                log WARN "  processOnlyHighVolume: true (optional, for targeted processing)"
                log WARN ""
                for entry in "${high_volume_ns_list[@]}"; do
                  ns_name="${entry%:*}"
                  ns_count="${entry#*:}"
                  log WARN "  - $ns_name: $ns_count ConfigMaps"
                done
                log WARN "========================================="
                log WARN ""
              fi
              
              log INFO "ConfigMap Statistics:"
              log INFO "  Deleted (or would delete): $total_deleted"
              log INFO "  Skipped total: $total_skipped"
              log INFO "    - System ConfigMaps (injected): $total_system_cm"
              log INFO "    - Protected by labels: $total_protected"
              log INFO "    - Too new (less than $MIN_AGE_DAYS days): $total_too_new"
              log INFO "    - Referenced by workloads: $total_referenced"
              log INFO ""
              log INFO "Errors: $total_errors"
              log INFO "Mode: $(if [[ "$DRY_RUN" == "true" ]]; then echo "DRY-RUN (no actual deletions)"; else echo "LIVE (deletions performed)"; fi)"
              if [[ "$PROCESS_HIGH_VOLUME" == "true" ]]; then
                log INFO "High-Volume Processing: ENABLED (pagination limit: $PAGINATION_LIMIT)"
              fi
              if [[ "$PROCESS_ONLY_HIGH_VOLUME" == "true" ]]; then
                log INFO "High-Volume Only Mode: ENABLED (skipped $namespaces_skipped_by_mode normal namespaces)"
              fi
              log INFO "========================================="
              
              exit 0



