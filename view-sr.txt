Steps to Deploy the OpenShift Manifest Viewer Solution
Here's a step-by-step guide to deploy the OpenShift Manifest Viewer application:
1. Prepare Your Environment
bashCopy# Log in to your OpenShift cluster
oc login --token=<your-token> --server=<your-cluster-url>

# Create a new project
oc new-project manifest-viewer
2. Build the Application Image
bashCopy# Create a directory for your project
mkdir -p manifest-viewer && cd manifest-viewer

# Create all the necessary files as provided in the previous messages
# (React components, configuration files, Dockerfile, etc.)

# Build the Docker image
docker build -t manifest-viewer:latest .

# Tag the image for your registry
docker tag manifest-viewer:latest <your-registry>/manifest-viewer:latest

# Push the image to your registry
docker push <your-registry>/manifest-viewer:latest
3. Create OAuth Client in OpenShift
bashCopy# Create an OAuth client for your application
cat <<EOF | oc create -f -
apiVersion: oauth.openshift.io/v1
kind: OAuthClient
metadata:
  name: manifest-viewer
redirect_uris:
  - https://manifest-viewer.apps.<your-cluster-domain>/oauth/callback
grantMethod: auto
EOF
4. Deploy the ConfigMap
bashCopy# Create the ConfigMap with your cluster-specific configuration
cat <<EOF | oc apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: manifest-viewer-config
data:
  app-config.json: |
    {
      "clusterName": "Your OpenShift Cluster",
      "oauthConfig": {
        "clientId": "manifest-viewer",
        "authorizationEndpoint": "https://oauth-openshift.apps.<your-cluster-domain>/oauth/authorize",
        "tokenEndpoint": "https://oauth-openshift.apps.<your-cluster-domain>/oauth/token",
        "redirectUri": "https://manifest-viewer.apps.<your-cluster-domain>/oauth/callback",
        "scope": "user:full"
      },
      "availableViews": [
        {
          "kind": "Pod",
          "apiVersion": "v1",
          "displayName": "Pods",
          "description": "Kubernetes Pod resources",
          "icon": "container",
          "defaultColumns": ["name", "namespace", "status", "restarts", "age"]
        },
        {
          "kind": "Deployment",
          "apiVersion": "apps/v1",
          "displayName": "Deployments",
          "description": "Kubernetes Deployment resources",
          "icon": "deployment",
          "defaultColumns": ["name", "namespace", "replicas", "updatedReplicas", "availableReplicas", "age"]
        }
      ],
      "uiSettings": {
        "theme": "light",
        "refreshInterval": 60,
        "defaultView": "Pod",
        "showClusterInfo": true
      }
    }
EOF
5. Deploy the Application
bashCopy# Create the deployment
cat <<EOF | oc apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: manifest-viewer
  labels:
    app: manifest-viewer
spec:
  replicas: 2
  selector:
    matchLabels:
      app: manifest-viewer
  template:
    metadata:
      labels:
        app: manifest-viewer
    spec:
      containers:
      - name: manifest-viewer
        image: <your-registry>/manifest-viewer:latest
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: config-volume
          mountPath: /usr/share/nginx/html/config
        resources:
          limits:
            cpu: "500m"
            memory: "512Mi"
          requests:
            cpu: "200m"
            memory: "256Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: config-volume
        configMap:
          name: manifest-viewer-config
EOF

# Create the service
cat <<EOF | oc apply -f -
apiVersion: v1
kind: Service
metadata:
  name: manifest-viewer
spec:
  selector:
    app: manifest-viewer
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
EOF

# Create the route
cat <<EOF | oc apply -f -
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: manifest-viewer
spec:
  to:
    kind: Service
    name: manifest-viewer
  port:
    targetPort: 8080
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Redirect
EOF
6. Set Up RBAC (Role-Based Access Control)
bashCopy# Create a service account for the application
oc create serviceaccount manifest-viewer-sa

# Create a role with the necessary permissions
cat <<EOF | oc apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: manifest-viewer-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["route.openshift.io"]
  resources: ["routes"]
  verbs: ["get", "list", "watch"]
EOF

# Bind the role to the service account
oc create clusterrolebinding manifest-viewer-binding \
  --clusterrole=manifest-viewer-role \
  --serviceaccount=manifest-viewer:manifest-viewer-sa
7. Verify the Deployment
bashCopy# Check if the pods are running
oc get pods

# Get the URL of your application
oc get route manifest-viewer

# Check logs if there are any issues
oc logs -f deployment/manifest-viewer
8. Update Configuration (When Needed)
bashCopy# Edit the ConfigMap
oc edit configmap manifest-viewer-config

# Or apply a new version
oc apply -f updated-config.yaml

# Restart the pods to pick up the new configuration
oc rollout restart deployment/manifest-viewer
9. Access the Application

Open the Route URL in your browser (https://manifest-viewer.apps.<your-cluster-domain>)
You will be redirected to the OpenShift login page
After authentication, you'll be able to use the Manifest Viewer application

10. Troubleshooting
If you encounter issues:
bashCopy# Check pod status
oc get pods

# Check pod logs
oc logs <pod-name>

# Check events
oc get events

# Check ConfigMap is mounted correctly
oc exec <pod-name> -- ls -la /usr/share/nginx/html/config

# Check ConfigMap content
oc exec <pod-name> -- cat /usr/share/nginx/html/config/app-config.json










Complete Step-by-Step Deployment Guide
1. Set Up Project Structure
bashCopy# Create project directory
mkdir -p manifest-viewer
cd manifest-viewer

# Create subdirectories
mkdir -p public src/components src/contexts src/services src/styles kubernetes
2. Create Backend Files
First, create the NGINX configuration and Docker files:
bashCopy# Create NGINX configuration
cat > nginx.conf << 'EOF'
server {
    listen 8080;
    server_name localhost;
    root /usr/share/nginx/html;
    
    # Enable gzip compression
    gzip on;
    gzip_comp_level 5;
    gzip_types text/plain text/css application/javascript application/json;
    
    # Health check endpoint
    location /health {
        access_log off;
        return 200 "OK";
    }
    
    # Readiness check endpoint
    location /ready {
        access_log off;
        return 200 "Ready";
    }
    
    # Serve static files
    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "public, max-age=3600";
    }
    
    # Proxy API requests to the backend
    location /api/ {
        proxy_pass https://kubernetes.default.svc/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Pass through the authorization header
        proxy_set_header Authorization $http_authorization;
    }
    
    # Allow direct access to config directory
    location /config/ {
        alias /usr/share/nginx/html/config/;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }
    
    # Handle OAuth redirect
    location /oauth/callback {
        try_files $uri $uri/ /index.html;
    }
    
    # Error pages
    error_page 404 /index.html;
    error_page 500 502 503 504 /error.html;
}
EOF

# Create Docker entrypoint script
cat > docker-entrypoint.sh << 'EOF'
#!/bin/sh
set -e

# If the config directory is empty, copy default config
if [ ! -f /usr/share/nginx/html/config/app-config.json ]; then
  echo "No config found, copying default configuration..."
  cp /usr/share/nginx/html/default-config.json /usr/share/nginx/html/config/app-config.json
fi

# Start CMD
exec "$@"
EOF
chmod +x docker-entrypoint.sh

# Create Dockerfile
cat > Dockerfile << 'EOF'
FROM node:16 AS builder

WORKDIR /app

# Copy package files and install dependencies
COPY package.json package-lock.json ./
RUN npm ci

# Copy source code
COPY public ./public
COPY src ./src

# Build the application
RUN npm run build

# Production image
FROM nginx:1.21-alpine

# Copy nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Copy built assets from builder stage
COPY --from=builder /app/build /usr/share/nginx/html

# Create directory for mounted ConfigMap
RUN mkdir -p /usr/share/nginx/html/config

# Simple entrypoint script to handle ConfigMap mounting
COPY docker-entrypoint.sh /
RUN chmod +x /docker-entrypoint.sh

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]
EOF
3. Create Kubernetes Manifests
bashCopy# Create ConfigMap
cat > kubernetes/configmap.yaml << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: manifest-viewer-config
data:
  app-config.json: |
    {
      "clusterName": "OpenShift Cluster",
      "oauthConfig": {
        "clientId": "manifest-viewer",
        "authorizationEndpoint": "https://oauth-openshift.apps.cluster-domain.example.com/oauth/authorize",
        "tokenEndpoint": "https://oauth-openshift.apps.cluster-domain.example.com/oauth/token",
        "redirectUri": "https://manifest-viewer.apps.cluster-domain.example.com/oauth/callback",
        "scope": "user:full"
      },
      "availableViews": [
        {
          "kind": "Pod",
          "apiVersion": "v1",
          "displayName": "Pods",
          "description": "Kubernetes Pod resources",
          "icon": "container",
          "defaultColumns": ["name", "namespace", "status", "restarts", "age"]
        },
        {
          "kind": "Deployment",
          "apiVersion": "apps/v1",
          "displayName": "Deployments",
          "description": "Kubernetes Deployment resources",
          "icon": "deployment",
          "defaultColumns": ["name", "namespace", "replicas", "updatedReplicas", "availableReplicas", "age"]
        },
        {
          "kind": "Service",
          "apiVersion": "v1",
          "displayName": "Services",
          "description": "Kubernetes Service resources",
          "icon": "network",
          "defaultColumns": ["name", "namespace", "type", "clusterIP", "ports", "age"]
        },
        {
          "kind": "Route",
          "apiVersion": "route.openshift.io/v1",
          "displayName": "Routes",
          "description": "OpenShift Route resources",
          "icon": "route",
          "defaultColumns": ["name", "namespace", "host", "services", "port", "age"]
        }
      ],
      "uiSettings": {
        "theme": "light",
        "refreshInterval": 60,
        "defaultView": "Deployment",
        "showClusterInfo": true
      }
    }
EOF

# Create Deployment
cat > kubernetes/deployment.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: manifest-viewer
  labels:
    app: manifest-viewer
spec:
  replicas: 2
  selector:
    matchLabels:
      app: manifest-viewer
  template:
    metadata:
      labels:
        app: manifest-viewer
    spec:
      containers:
      - name: manifest-viewer
        image: manifest-viewer:latest
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: config-volume
          mountPath: /usr/share/nginx/html/config
        resources:
          limits:
            cpu: "500m"
            memory: "512Mi"
          requests:
            cpu: "200m"
            memory: "256Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: config-volume
        configMap:
          name: manifest-viewer-config
EOF

# Create Service
cat > kubernetes/service.yaml << 'EOF'
apiVersion: v1
kind: Service
metadata:
  name: manifest-viewer
spec:
  selector:
    app: manifest-viewer
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
EOF

# Create Route
cat > kubernetes/route.yaml << 'EOF'
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: manifest-viewer
spec:
  to:
    kind: Service
    name: manifest-viewer
  port:
    targetPort: 8080
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Redirect
EOF

# Create RBAC
cat > kubernetes/rbac.yaml << 'EOF'
# Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: manifest-viewer-sa
---
# Cluster Role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: manifest-viewer-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["route.openshift.io"]
  resources: ["routes"]
  verbs: ["get", "list", "watch"]
---
# Cluster Role Binding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: manifest-viewer-binding
subjects:
- kind: ServiceAccount
  name: manifest-viewer-sa
  namespace: manifest-viewer
roleRef:
  kind: ClusterRole
  name: manifest-viewer-role
  apiGroup: rbac.authorization.k8s.io
EOF

# Create OAuth client
cat > kubernetes/oauth-client.yaml << 'EOF'
apiVersion: oauth.openshift.io/v1
kind: OAuthClient
metadata:
  name: manifest-viewer
redirect_uris:
  - https://manifest-viewer.apps.cluster-domain.example.com/oauth/callback
grantMethod: auto
EOF
4. Create React Application Files
4.1 Create package.json and HTML entry point
bashCopy# Create package.json
cat > package.json << 'EOF'
{
  "name": "manifest-viewer",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@ant-design/icons": "^4.7.0",
    "antd": "^4.18.0",
    "axios": "^0.24.0",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-json-view": "^1.21.3",
    "react-router-dom": "^6.2.1",
    "yaml": "^2.0.0"
  },
  "devDependencies": {
    "react-scripts": "5.0.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
EOF

# Create public/index.html
mkdir -p public
cat > public/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="OpenShift Manifest Viewer" />
    <title>OpenShift Manifest Viewer</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
EOF

# Create default config
cat > public/default-config.json << 'EOF'
{
  "clusterName": "OpenShift Cluster",
  "oauthConfig": {
    "clientId": "manifest-viewer",
    "authorizationEndpoint": "/oauth/authorize",
    "tokenEndpoint": "/oauth/token",
    "redirectUri": "http://localhost:3000/oauth/callback",
    "scope": "user:full"
  },
  "availableViews": [
    {
      "kind": "Pod",
      "apiVersion": "v1",
      "displayName": "Pods",
      "description": "Kubernetes Pod resources",
      "icon": "container",
      "defaultColumns": ["name", "namespace", "status", "restarts", "age"]
    },
    {
      "kind": "Deployment",
      "apiVersion": "apps/v1",
      "displayName": "Deployments",
      "description": "Kubernetes Deployment resources",
      "icon": "deployment",
      "defaultColumns": ["name", "namespace", "replicas", "updatedReplicas", "availableReplicas", "age"]
    }
  ],
  "uiSettings": {
    "theme": "light",
    "refreshInterval": 30,
    "defaultView": "Pod",
    "showClusterInfo": true
  }
}
EOF
4.2 Create React Components (Main Components)
Create the React source files for the application:
bashCopy# Create src/index.js
mkdir -p src
cat > src/index.js << 'EOF'
import React from 'react';
import ReactDOM from 'react-dom';
import './styles/index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
EOF

# Create main App.js
cat > src/App.js << 'EOF'
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Layout, Spin } from 'antd';
import { initializeConfig } from './services/configService';
import { isAuthenticated } from './services/authService';
import { ViewProvider } from './contexts/ViewContext';

import Login from './components/Login';
import OAuthCallback from './components/OAuthCallback';
import ResourceTree from './components/ResourceTree';
import ResourceDetail from './components/ResourceDetail';
import CustomViewBuilder from './components/CustomViewBuilder';

const { Header, Sider, Content } = Layout;

function App() {
  const [loading, setLoading] = useState(true);
  const [authenticated, setAuthenticated] = useState(false);
  const [selectedResource, setSelectedResource] = useState(null);

  useEffect(() => {
    const init = async () => {
      try {
        // Initialize configuration
        await initializeConfig();
        
        // Check authentication
        const authStatus = await isAuthenticated();
        setAuthenticated(authStatus);
      } catch (error) {
        console.error('Initialization error:', error);
      } finally {
        setLoading(false);
      }
    };
    
    init();
  }, []);
  
  // Handle resource selection
  const handleResourceSelect = (resource) => {
    setSelectedResource(resource);
  };
  
  // Handle resource update
  const handleResourceUpdated = () => {
    // Refresh data as needed
  };

  if (loading) {
    return (
      <div className="app-loading">
        <Spin size="large" tip="Initializing application..." />
      </div>
    );
  }

  // Protected route component
  const ProtectedRoute = ({ children }) => {
    if (!authenticated) {
      return <Navigate to="/login" />;
    }
    return children;
  };

  return (
    <Router>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/oauth/callback" element={<OAuthCallback />} />
        <Route path="/" element={
          <ProtectedRoute>
            <ViewProvider>
              <Layout style={{ minHeight: '100vh' }}>
                <Header className="app-header">
                  <div className="logo">OpenShift Manifest Viewer</div>
                </Header>
                <Layout>
                  <Sider width={300} theme="light">
                    <CustomViewBuilder />
                    <ResourceTree onResourceSelect={handleResourceSelect} />
                  </Sider>
                  <Content className="main-content">
                    <ResourceDetail 
                      resource={selectedResource} 
                      onResourceUpdated={handleResourceUpdated} 
                    />
                  </Content>
                </Layout>
              </Layout>
            </ViewProvider>
          </ProtectedRoute>
        } />
      </Routes>
    </Router>
  );
}

export default App;
EOF

# Create CSS styles
mkdir -p src/styles
cat > src/styles/index.css << 'EOF'
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.app-loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.app-header {
  display: flex;
  align-items: center;
  background-color: #2b2f3a;
  padding: 0 20px;
}

.app-header .logo {
  color: white;
  font-size: 18px;
  font-weight: bold;
}

.main-content {
  padding: 20px;
  background-color: #f0f2f5;
  overflow: auto;
}

.resource-tree-container {
  padding: 12px;
}

.tree-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.tree-loading {
  display: flex;
  justify-content: center;
  padding: 30px 0;
}

.resource-detail-container {
  background-color: white;
  padding: 20px;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.detail-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.resource-title h3 {
  margin-bottom: 5px;
}

.json-viewer {
  padding: 10px;
  border-radius: 4px;
  background-color: #2b2f3a;
}

.resource-detail-placeholder {
  height: 300px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: #999;
  background-color: white;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.custom-view-builder {
  padding: 12px;
  border-bottom: 1px solid #f0f0f0;
}
EOF
4.3 Create Service Layer Files
bashCopy# Create context files
mkdir -p src/contexts
cat > src/contexts/ViewContext.js << 'EOF'
import React, { createContext, useContext, useState, useEffect } from 'react';
import { getAvailableViews } from '../services/configService';

const ViewContext = createContext();

export const useViewContext = () => useContext(ViewContext);

export const ViewProvider = ({ children }) => {
  const [availableViews, setAvailableViews] = useState([]);
  const [selectedView, setSelectedView] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadViews = async () => {
      try {
        const views = getAvailableViews();
        setAvailableViews(views);
        
        // Set default view if available
        if (views.length > 0) {
          setSelectedView(views[0]);
        }
      } catch (error) {
        console.error('Failed to load views:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadViews();
  }, []);

  const selectView = (view) => {
    setSelectedView(view);
  };

  return (
    <ViewContext.Provider value={{ 
      availableViews, 
      selectedView, 
      selectView,
      loading
    }}>
      {children}
    </ViewContext.Provider>
  );
};
EOF

# Create service files
mkdir -p src/services
cat > src/services/apiService.js << 'EOF'
import axios from 'axios';
import { getAccessToken } from './authService';

// Read API URL from environment or config
const API_BASE_URL = process.env.REACT_APP_API_URL || '/api';

// Create axios instance with interceptors for auth
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
});

// Add authorization header to all requests
apiClient.interceptors.request.use(
  async (config) => {
    const token = await getAccessToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Handle authentication errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Redirect to login page
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// Fetch available resources/views from config
export const fetchAvailableViews = async () => {
  try {
    const response = await apiClient.get('/config/views');
    return response.data;
  } catch (error) {
    console.error('Error fetching available views:', error);
    throw error;
  }
};

// Fetch cluster resources of a specific type
export const fetchResources = async (apiVersion, kind, namespace = null) => {
  try {
    let url = `/resources/${apiVersion}/${kind}`;
    if (namespace) {
      url = `${url}?namespace=${namespace}`;
    }
    
    const response = await apiClient.get(url);
    return response.data.items || [];
  } catch (error) {
    console.error(`Error fetching ${kind} resources:`, error);
    throw error;
  }
};

// Fetch a specific resource
export const fetchResource = async (kind, namespace, name) => {
  try {
    let url = `/resources/${kind}/${name}`;
    if (namespace && namespace !== 'cluster-wide') {
      url = `/resources/${kind}/namespaces/${namespace}/${name}`;
    }
    
    const response = await apiClient.get(url);
    return response.data;
  } catch (error) {
    console.error(`Error fetching resource ${kind}/${name}:`, error);
    throw error;
  }
};

// Update a specific resource
export const updateResource = async (kind, namespace, name, resource) => {
  try {
    let url = `/resources/${kind}/${name}`;
    if (namespace && namespace !== 'cluster-wide') {
      url = `/resources/${kind}/namespaces/${namespace}/${name}`;
    }
    
    const response = await apiClient.put(url, resource);
    return response.data;
  } catch (error) {
    console.error(`Error updating resource ${kind}/${name}:`, error);
    throw error;
  }
};

// Fetch cluster info
export const fetchClusterInfo = async () => {
  try {
    const response = await apiClient.get('/cluster');
    return response.data;
  } catch (error) {
    console.error('Error fetching cluster info:', error);
    throw error;
  }
};

// Fetch user info and permissions
export const fetchUserInfo = async () => {
  try {
    const response = await apiClient.get('/auth/user');
    return response.data;
  } catch (error) {
    console.error('Error fetching user info:', error);
    throw error;
  }
};
EOF

cat > src/services/authService.js << 'EOF'
import { getOAuthConfig } from './configService';

// Store for authentication data
let authData = {
  accessToken: null,
  refreshToken: null,
  expiresAt: null
};

// Check if user is authenticated
export const isAuthenticated = () => {
  const token = localStorage.getItem('accessToken');
  const expiresAt = localStorage.getItem('expiresAt');
  
  if (!token || !expiresAt) {
    return false;
  }
  
  // Check if token is expired
  if (Date.now() >= parseInt(expiresAt, 10)) {
    return false;
  }
  
  // Token exists and is not expired
  authData.accessToken = token;
  authData.refreshToken = localStorage.getItem('refreshToken');
  authData.expiresAt = parseInt(expiresAt, 10);
  
  return true;
};

// Initiate OAuth login flow
export const login = () => {
  const { clientId, authorizationEndpoint, redirectUri, scope } = getOAuthConfig();
  
  // Generate and store state for CSRF protection
  const state = generateRandomString(30);
  localStorage.setItem('oauth_state', state);
  
  // Build authorization URL
  const params = new URLSearchParams({
    client_id: clientId,
    redirect_uri: redirectUri,
    response_type: 'code',
    scope: scope,
    state: state
  });
  
  // Redirect to authorization endpoint
  window.location.href = `${authorizationEndpoint}?${params.toString()}`;
};

// Handle OAuth callback
export const handleCallback = async (code, state) => {
  // Verify state to prevent CSRF
  const storedState = localStorage.getItem('oauth_state');
  if (state !== storedState) {
    throw new Error('OAuth state mismatch');
  }
  
  // Clear stored state
  localStorage.removeItem('oauth_state');
  
  // Exchange code for token
  const { clientId, tokenEndpoint, redirectUri } = getOAuthConfig();
  
  const tokenResponse = await fetch(tokenEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      client_id: clientId,
      redirect_uri: redirectUri,
      code: code
    })
  });
  
  if (!tokenResponse.ok) {
    throw new Error('Failed to exchange code for token');
  }
  
  const tokenData = await tokenResponse.json();
  
  // Save tokens
  const expiresAt = Date.now() + (tokenData.expires_in * 1000);
  localStorage.setItem('accessToken', tokenData.access_token);
  localStorage.setItem('refreshToken', tokenData.refresh_token);
  localStorage.setItem('expiresAt', expiresAt.toString());
  
  // Update auth data
  authData = {
    accessToken: tokenData.access_token,
    refreshToken: tokenData.refresh_token,
    expiresAt: expiresAt
  };
  
  return true;
};

// Get access token (refreshing if needed)
export const getAccessToken = async () => {
  // If not authenticated, return null
  if (!isAuthenticated()) {
    return null;
  }
  
  // If token is about to expire, refresh it
  if (Date.now() >= authData.expiresAt - 60000) { // 1 minute buffer
    await refreshToken();
  }
  
  return authData.accessToken;
};

// Refresh the access token
const refreshToken = async () => {
  if (!authData.refreshToken) {
    throw new Error('No refresh token available');
  }
  
  const { clientId, tokenEndpoint } = getOAuthConfig();
  
  const tokenResponse = await fetch(tokenEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      client_id: clientId,
      refresh_token: authData.refreshToken
    })
  });
  
  if (!tokenResponse.ok) {
    throw new Error('Failed to refresh token');
  }
  
  const tokenData = await tokenResponse.json();
  
  // Save new tokens
  const expiresAt = Date.now() + (tokenData.expires_in * 1000);
  localStorage.setItem('accessToken', tokenData.access_token);
  
  // Some OAuth servers return a new refresh token, some don't
  if (tokenData.refresh_token) {
    localStorage.setItem('refreshToken', tokenData.refresh_token);
    authData.refreshToken = tokenData.refresh_token;
  }
  
  localStorage.setItem('expiresAt', expiresAt.toString());
  
  // Update auth data
  authData.accessToken = tokenData.access_token;
  authData.expiresAt = expiresAt;
  
  return true;
};

// Log out
export const logout = () => {
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
  localStorage.removeItem('expiresAt');
  
  authData = {
    accessToken: null,
    refreshToken: null,
    expiresAt: null
  };
  
  // Redirect to login page
  window.location.href = '/login';
};

// Generate random string for state
const generateRandomString = (length) => {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));



4.3 Create Service Layer Files (continued)
Let's create the remaining service files:
bashCopy# Create config service
cat > src/services/configService.js << 'EOF'
// Application configuration service
let appConfig = null;

// Initialize configuration by loading from server
export const initializeConfig = async () => {
  try {
    const response = await fetch('/config/app-config.json');
    if (!response.ok) {
      throw new Error('Failed to load configuration');
    }
    
    appConfig = await response.json();
    return true;
  } catch (error) {
    console.error('Error loading configuration:', error);
    // Fall back to default config for development
    const defaultResponse = await fetch('/default-config.json');
    if (defaultResponse.ok) {
      appConfig = await defaultResponse.json();
      return true;
    }
    throw error;
  }
};

// Get OAuth configuration
export const getOAuthConfig = () => {
  if (!appConfig) {
    throw new Error('Configuration not initialized');
  }
  return appConfig.oauthConfig;
};

// Get available resource views
export const getAvailableViews = () => {
  if (!appConfig) {
    throw new Error('Configuration not initialized');
  }
  return appConfig.availableViews || [];
};

// Get UI settings
export const getUISettings = () => {
  if (!appConfig) {
    throw new Error('Configuration not initialized');
  }
  return appConfig.uiSettings || {};
};

// Get cluster name
export const getClusterName = () => {
  if (!appConfig) {
    throw new Error('Configuration not initialized');
  }
  return appConfig.clusterName || 'OpenShift Cluster';
};
EOF
4.4 Create React Components (Individual Components)
Now, let's create the main individual components:
bashCopy# Create Login component
mkdir -p src/components
cat > src/components/Login.js << 'EOF'
import React, { useEffect } from 'react';
import { Card, Button, Typography } from 'antd';
import { login, isAuthenticated } from '../services/authService';
import { useNavigate } from 'react-router-dom';
import { getClusterName } from '../services/configService';

const { Title, Paragraph } = Typography;

const Login = () => {
  const navigate = useNavigate();
  
  useEffect(() => {
    // Redirect to main page if already authenticated
    if (isAuthenticated()) {
      navigate('/');
    }
  }, [navigate]);
  
  const handleLogin = () => {
    login();
  };
  
  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      height: '100vh',
      background: '#f0f2f5'
    }}>
      <Card style={{ width: 400, textAlign: 'center', borderRadius: 8 }}>
        <Title level={2}>OpenShift Manifest Viewer</Title>
        <Paragraph>
          Connect to {getClusterName()} to view and manage Kubernetes resources.
        </Paragraph>
        <Button 
          type="primary" 
          size="large" 
          onClick={handleLogin}
          style={{ width: '100%' }}
        >
          Login with OpenShift
        </Button>
      </Card>
    </div>
  );
};

export default Login;
EOF

# Create OAuth Callback component
cat > src/components/OAuthCallback.js << 'EOF'
import React, { useEffect, useState } from 'react';
import { Spin, Result } from 'antd';
import { useNavigate, useLocation } from 'react-router-dom';
import { handleCallback } from '../services/authService';

const OAuthCallback = () => {
  const [error, setError] = useState(null);
  const navigate = useNavigate();
  const location = useLocation();
  
  useEffect(() => {
    const processCallback = async () => {
      try {
        // Parse query parameters
        const queryParams = new URLSearchParams(location.search);
        const code = queryParams.get('code');
        const state = queryParams.get('state');
        
        if (!code) {
          throw new Error('No authorization code received');
        }
        
        // Process the callback
        await handleCallback(code, state);
        
        // Redirect to main page
        navigate('/');
      } catch (err) {
        console.error('OAuth callback error:', err);
        setError(err.message);
      }
    };
    
    processCallback();
  }, [location, navigate]);
  
  if (error) {
    return (
      <Result
        status="error"
        title="Authentication Failed"
        subTitle={error}
        extra={[
          <a key="login" href="/login">
            Try Again
          </a>
        ]}
      />
    );
  }
  
  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      height: '100vh' 
    }}>
      <Spin size="large" tip="Completing authentication..." />
    </div>
  );
};

export default OAuthCallback;
EOF

# Create ResourceTree component
cat > src/components/ResourceTree.js << 'EOF'
import React, { useState, useEffect } from 'react';
import { Tree, Input, Select, Spin, Empty, Button } from 'antd';
import { SearchOutlined, ReloadOutlined } from '@ant-design/icons';
import { useViewContext } from '../contexts/ViewContext';
import { fetchResources } from '../services/apiService';

const { Option } = Select;

const ResourceTree = ({ onResourceSelect }) => {
  const { selectedView } = useViewContext();
  const [treeData, setTreeData] = useState([]);
  const [expandedKeys, setExpandedKeys] = useState([]);
  const [loading, setLoading] = useState(false);
  const [searchValue, setSearchValue] = useState('');
  const [selectedNamespace, setSelectedNamespace] = useState('all');
  const [namespaces, setNamespaces] = useState([]);
  
  // Load namespaces
  useEffect(() => {
    const fetchNamespaces = async () => {
      try {
        const namespacesData = await fetchResources('v1', 'Namespace');
        setNamespaces(namespacesData.map(ns => ns.metadata.name));
      } catch (error) {
        console.error('Failed to fetch namespaces:', error);
      }
    };
    
    fetchNamespaces();
  }, []);
  
  // Load resources for selected view
  useEffect(() => {
    if (!selectedView) return;
    
    const loadResources = async () => {
      setLoading(true);
      try {
        const namespace = selectedNamespace === 'all' ? null : selectedNamespace;
        const resources = await fetchResources(
          selectedView.apiVersion,
          selectedView.kind,
          namespace
        );
        
        // Transform into tree structure
        const transformedData = transformToTreeData(resources);
        setTreeData(transformedData);
        
        // Expand namespace nodes by default
        if (selectedNamespace === 'all') {
          setExpandedKeys(transformedData.map(item => item.key));
        }
      } catch (error) {
        console.error('Failed to load resources:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadResources();
  }, [selectedView, selectedNamespace]);
  
  // Transform resources into tree structure
  const transformToTreeData = (resources) => {
    // Group by namespace for namespace-scoped resources
    const namespaceGroups = {};
    
    resources.forEach(resource => {
      const namespace = resource.metadata.namespace || 'cluster-wide';
      
      if (!namespaceGroups[namespace]) {
        namespaceGroups[namespace] = [];
      }
      
      namespaceGroups[namespace].push({
        title: resource.metadata.name,
        key: `${namespace}/${resource.metadata.name}`,
        resource: resource,
        isLeaf: true
      });
    });
    
    // Create tree structure
    return Object.keys(namespaceGroups).map(namespace => ({
      title: namespace,
      key: namespace,
      selectable: false,
      children: namespaceGroups[namespace]
    }));
  };
  
  // Handle tree node selection
  const handleSelect = (selectedKeys, info) => {
    if (info.node.isLeaf) {
      onResourceSelect(info.node.resource);
    }
  };
  
  // Handle tree expansion
  const handleExpand = (expandedKeys) => {
    setExpandedKeys(expandedKeys);
  };
  
  // Handle search
  const handleSearch = (e) => {
    setSearchValue(e.target.value);
  };
  
  // Filter tree data based on search
  const filterTreeData = (treeData, searchValue) => {
    if (!searchValue) return treeData;
    
    const filteredData = [];
    
    // Helper function to filter nodes
    const filterNodes = (nodes, parent) => {
      return nodes.filter(node => {
        const matched = node.title.toLowerCase().includes(searchValue.toLowerCase());
        
        if (node.children && node.children.length > 0) {
          const filteredChildren = filterNodes(node.children, node);
          node.children = filteredChildren;
          
          // Keep parent if it has matching children
          return matched || filteredChildren.length > 0;
        }
        
        return matched;
      });
    };
    
    filteredData.push(...filterNodes(treeData));
    return filteredData;
  };
  
  // Refresh resources
  const handleRefresh = () => {
    if (selectedView) {
      // Re-fetch resources
      setSearchValue('');
      setLoading(true);
      fetchResources(
        selectedView.apiVersion, 
        selectedView.kind, 
        selectedNamespace === 'all' ? null : selectedNamespace
      )
        .then(resources => {
          const transformedData = transformToTreeData(resources);
          setTreeData(transformedData);
        })
        .catch(error => {
          console.error('Failed to refresh resources:', error);
        })
        .finally(() => {
          setLoading(false);
        });
    }
  };
  
  const filteredTreeData = filterTreeData(treeData, searchValue);
  
  return (
    <div className="resource-tree-container">
      <div className="tree-header">
        <h3>{selectedView ? selectedView.displayName : 'Resources'}</h3>
        <Button 
          type="text" 
          icon={<ReloadOutlined />} 
          onClick={handleRefresh}
          disabled={loading}
        />
      </div>
      
      <div style={{ marginBottom: 16 }}>
        <Select
          value={selectedNamespace}
          onChange={setSelectedNamespace}
          style={{ width: '100%', marginBottom: 8 }}
          placeholder="Select namespace"
        >
          <Option value="all">All Namespaces</Option>
          {namespaces.map(ns => (
            <Option key={ns} value={ns}>{ns}</Option>
          ))}
        </Select>
        
        <Input
          placeholder="Search resources"
          value={searchValue}
          onChange={handleSearch}
          prefix={<SearchOutlined />}
        />
      </div>
      
      {loading ? (
        <div className="tree-loading">
          <Spin />
        </div>
      ) : filteredTreeData.length > 0 ? (
        <Tree
          showLine={{ showLeafIcon: false }}
          showIcon={false}
          onSelect={handleSelect}
          onExpand={handleExpand}
          expandedKeys={expandedKeys}
          treeData={filteredTreeData}
        />
      ) : (
        <Empty 
          description={
            searchValue ? "No resources found matching your search" : "No resources found"
          } 
          image={Empty.PRESENTED_IMAGE_SIMPLE} 
        />
      )}
    </div>
  );
};

export default ResourceTree;
EOF

# Create ResourceDetail component
cat > src/components/ResourceDetail.js << 'EOF'
import React, { useState } from 'react';
import { Tabs, Button, Spin, Empty, message } from 'antd';
import { EditOutlined, SaveOutlined, CloseOutlined } from '@ant-design/icons';
import ReactJson from 'react-json-view';
import YAML from 'yaml';
import { updateResource } from '../services/apiService';

const { TabPane } = Tabs;

const ResourceDetail = ({ resource, onResourceUpdated }) => {
  const [activeTab, setActiveTab] = useState('json');
  const [isEditing, setIsEditing] = useState(false);
  const [editedResource, setEditedResource] = useState(null);
  const [saving, setSaving] = useState(false);
  
  if (!resource) {
    return (
      <div className="resource-detail-placeholder">
        <Empty 
          description="Select a resource to view details" 
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        />
      </div>
    );
  }
  
  // Start editing resource
  const handleEdit = () => {
    setEditedResource(JSON.parse(JSON.stringify(resource)));
    setIsEditing(true);
  };
  
  // Cancel editing
  const handleCancelEdit = () => {
    setEditedResource(null);
    setIsEditing(false);
  };
  
  // Save edited resource
  const handleSave = async () => {
    if (!editedResource) return;
    
    setSaving(true);
    try {
      await updateResource(
        resource.kind,
        resource.metadata.namespace,
        resource.metadata.name,
        editedResource
      );
      
      message.success('Resource updated successfully');
      setIsEditing(false);
      
      if (onResourceUpdated) {
        onResourceUpdated();
      }
    } catch (error) {
      console.error('Failed to update resource:', error);
      message.error('Failed to update resource: ' + error.message);
    } finally {
      setSaving(false);
    }
  };
  
  // Handle JSON editor changes
  const handleJsonEdit = (edit) => {
    setEditedResource(edit.updated_src);
  };
  
  // Format object as YAML
  const formatYaml = (obj) => {
    return YAML.stringify(obj);
  };
  
  // Get the resource to display (original or edited)
  const displayResource = isEditing ? editedResource : resource;
  
  return (
    <div className="resource-detail-container">
      <div className="detail-header">
        <div className="resource-title">
          <h3>{resource.kind}: {resource.metadata.name}</h3>
          <div>
            {resource.metadata.namespace ? 
              `Namespace: ${resource.metadata.namespace}` : 
              'Cluster-wide resource'
            }
          </div>
        </div>
        
        <div>
          {isEditing ? (
            <>
              <Button 
                type="primary" 
                icon={<SaveOutlined />} 
                onClick={handleSave}
                loading={saving}
                style={{ marginRight: 8 }}
              >
                Save
              </Button>
              <Button 
                icon={<CloseOutlined />} 
                onClick={handleCancelEdit}
                disabled={saving}
              >
                Cancel
              </Button>
            </>
          ) : (
            <Button 
              icon={<EditOutlined />} 
              onClick={handleEdit}
            >
              Edit
            </Button>
          )}
        </div>
      </div>
      
      <Tabs activeKey={activeTab} onChange={setActiveTab}>
        <TabPane tab="JSON" key="json">
          {saving ? (
            <div style={{ textAlign: 'center', padding: 20 }}>
              <Spin tip="Saving..." />
            </div>
          ) : (
            <div className="json-viewer">
              <ReactJson 
                src={displayResource} 
                theme="monokai"
                displayDataTypes={false}
                displayObjectSize={false}
                enableClipboard={false}
                onEdit={isEditing ? handleJsonEdit : false}
                onAdd={isEditing ? handleJsonEdit : false}
                onDelete={isEditing ? handleJsonEdit : false}
              />
            </div>
          )}
        </TabPane>
        <TabPane tab="YAML" key="yaml">
          <pre style={{ background: '#f5f5f5', padding: 16, borderRadius: 4 }}>
            {formatYaml(displayResource)}
          </pre>
        </TabPane>
      </Tabs>
    </div>
  );
};

export default ResourceDetail;
EOF

# Create CustomViewBuilder component
cat > src/components/CustomViewBuilder.js << 'EOF'
import React, { useState } from 'react';
import { Select, Button, Drawer, Form, Input, Space, Tag } from 'antd';
import { FilterOutlined, PlusOutlined } from '@ant-design/icons';
import { useViewContext } from '../contexts/ViewContext';

const { Option } = Select;

const CustomViewBuilder = () => {
  const { availableViews, selectView, selectedView } = useViewContext();
  const [drawerVisible, setDrawerVisible] = useState(false);
  const [form] = Form.useForm();
  
  // Open custom filter drawer
  const showDrawer = () => {
    setDrawerVisible(true);
  };
  
  // Close drawer
  const onClose = () => {
    setDrawerVisible(false);
  };
  
  // Apply custom filter
  const handleApplyFilter = (values) => {
    // TODO: Implement custom filtering logic
    console.log('Filter values:', values);
    setDrawerVisible(false);
  };
  
  // Handle view selection
  const handleViewSelect = (value) => {
    const view = availableViews.find(v => `${v.kind}-${v.apiVersion}` === value);
    if (view) {
      selectView(view);
    }
  };
  
  return (
    <div className="custom-view-builder">
      <Space style={{ width: '100%' }} direction="vertical">
        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
          <h4>Resource Type</h4>
          <Button 
            type="text" 
            icon={<FilterOutlined />}
            onClick={showDrawer}
            size="small"
          />
        </div>
        
        <Select
          style={{ width: '100%' }}
          placeholder="Select resource type"
          value={selectedView ? `${selectedView.kind}-${selectedView.apiVersion}` : undefined}
          onChange={handleViewSelect}
        >
          {availableViews.map(view => (
            <Option 
              key={`${view.kind}-${view.apiVersion}`} 
              value={`${view.kind}-${view.apiVersion}`}
            >
              {view.displayName}
            </Option>
          ))}
        </Select>
        
        {selectedView && (
          <div style={{ marginTop: 8 }}>
            <Tag color="blue">{selectedView.kind}</Tag>
            <Tag color="green">{selectedView.apiVersion}</Tag>
          </div>
        )}
      </Space>
      
      <Drawer
        title="Custom View Filter"
        placement="right"
        onClose={onClose}
        visible={drawerVisible}
        width={400}
        footer={
          <div style={{ textAlign: 'right' }}>
            <Button onClick={onClose} style={{ marginRight: 8 }}>
              Cancel
            </Button>
            <Button 
              type="primary" 
              onClick={() => form.submit()}
            >
              Apply
            </Button>
          </div>
        }
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleApplyFilter}
        >
          <Form.Item
            name="labelSelector"
            label="Label Selector"
          >
            <Input placeholder="app=frontend,tier=web" />
          </Form.Item>
          
          <Form.Item
            name="fieldSelector"
            label="Field Selector"
          >
            <Input placeholder="status.phase=Running" />
          </Form.Item>
          
          <Form.List name="customColumns">
            {(fields, { add, remove }) => (
              <>
                <Form.Item label="Custom Columns">
                  <Button 
                    type="dashed" 
                    onClick={() => add()} 
                    block 
                    icon={<PlusOutlined />}
                  >
                    Add Column
                  </Button>
                </Form.Item>
                
                {fields.map(field => (
                  <Space key={field.key} style={{ display: 'flex', marginBottom: 8 }}>
                    <Form.Item
                      {...field}
                      name={[field.name, 'name']}
                      rules={[{ required: true, message: 'Column name required' }]}
                    >
                      <Input placeholder="Column name" />
                    </Form.Item>
                    
                    <Form.Item
                      {...field}
                      name={[field.name, 'jsonPath']}
                      rules={[{ required: true, message: 'JSONPath required' }]}
                    >
                      <Input placeholder="JSONPath" />
                    </Form.Item>
                    
                    <Button onClick={() => remove(field.name)} type="text" danger>
                      Remove
                    </Button>
                  </Space>
                ))}
              </>
            )}
          </Form.List>
        </Form>
      </Drawer>
    </div>
  );
};

export default CustomViewBuilder;
EOF

Build and Deploy Application

bashCopy# Install dependencies and build
npm install

# Build the application
npm run build

# Build Docker image
docker build -t manifest-viewer:latest .

# Deploy to Kubernetes
kubectl create namespace manifest-viewer
kubectl apply -f kubernetes/configmap.yaml -n manifest-viewer
kubectl apply -f kubernetes/deployment.yaml -n manifest-viewer
kubectl apply -f kubernetes/service.yaml -n manifest-viewer
kubectl apply -f kubernetes/route.yaml -n manifest-viewer
kubectl apply -f kubernetes/rbac.yaml -n manifest-viewer
kubectl apply -f kubernetes/oauth-client.yaml -n manifest-viewer

Post-Deployment Verification

bashCopy# Check if pods are running correctly
kubectl get pods -n manifest-viewer

# Check the route
kubectl get route manifest-viewer -n manifest-viewer

# Verify the ConfigMap is mounted correctly
kubectl describe pod -l app=manifest-viewer -n manifest-viewer

# Check service account and role binding
kubectl get serviceaccount manifest-viewer-sa -n manifest-viewer
kubectl get clusterrolebinding manifest-viewer-binding

Accessing the Application

Once the deployment is complete, access the application using the route URL:
Copyhttps://manifest-viewer.apps.cluster-domain.example.com

Troubleshooting Guide


Authentication Issues: Check OpenShift OAuth client configuration and redirect URI
Resource Visibility Issues: Verify RBAC permissions for the service account
ConfigMap Not Loading: Check volume mounts and ensure the config directory exists
API Access Problems: Verify proxy configuration in NGINX and ensure proper headers are set


Additional Notes


The application uses a ConfigMap for configuration, which can be updated without rebuilding the image
The NGINX configuration includes health checks and readiness probes for Kubernetes
OAuth authentication uses the OpenShift built-in identity provider
For production use, consider implementing:

Resource caching to reduce API calls
Rate limiting for API requests
More granular RBAC controls
Session timeout and refresh token handling





